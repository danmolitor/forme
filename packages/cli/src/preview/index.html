<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Forme Preview</title>
<style>
  :root {
    --bg: #0a0a0b;
    --surface: #18181b;
    --surface-2: #1f1f23;
    --border: #27272a;
    --border-hover: #3f3f46;
    --text: #fafafa;
    --text-muted: #a1a1aa;
    --text-dim: #71717a;
    --accent: #3b82f6;
    --accent-hover: #2563eb;
    --inspector-width: 320px;
    --left-sidebar-width: 280px;
    --toolbar-height: 44px;
    --font-mono: 'SF Mono', 'Fira Code', 'Cascadia Code', 'JetBrains Mono', monospace;
    --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: var(--font-sans);
    overflow: hidden;
    height: 100vh;
  }

  /* -- Toolbar ----------------------------------------- */
  #toolbar {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 200;
    height: var(--toolbar-height);
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    padding: 0 12px;
    gap: 12px;
    font-size: 13px;
    -webkit-app-region: drag;
  }

  .toolbar-group {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-shrink: 0;
  }

  .wordmark {
    font-weight: 700;
    font-size: 14px;
    letter-spacing: -0.02em;
    color: var(--text);
    user-select: none;
  }

  .wordmark span { color: var(--text-dim); font-weight: 400; }

  .toolbar-separator {
    width: 1px;
    height: 20px;
    background: var(--border);
    flex-shrink: 0;
  }

  /* -- Segmented Control -------------------------------- */
  .segmented-control {
    display: flex;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 2px;
    gap: 1px;
    -webkit-app-region: no-drag;
  }

  .segmented-control button {
    background: transparent;
    color: var(--text-muted);
    border: none;
    border-radius: 4px;
    padding: 4px 10px;
    font-size: 11px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s ease;
    white-space: nowrap;
    position: relative;
  }

  .segmented-control button:hover {
    color: var(--text);
    background: var(--surface-2);
  }

  .segmented-control button.active {
    background: var(--surface-2);
    color: var(--text);
    box-shadow: 0 1px 2px rgba(0,0,0,0.3);
  }

  .segmented-control button .shortcut {
    display: inline-block;
    margin-left: 4px;
    font-size: 9px;
    color: var(--text-dim);
    opacity: 0.6;
  }

  /* -- Toolbar meta ------------------------------------ */
  .toolbar-spacer { flex: 1; }

  .badge {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 11px;
    font-family: var(--font-mono);
    background: var(--bg);
    border: 1px solid var(--border);
    color: var(--text-dim);
  }

  .badge.render-time { color: #4ade80; }
  .badge.page-count { color: var(--text-muted); }

  /* -- Zoom controls ----------------------------------- */
  .zoom-controls {
    display: flex;
    align-items: center;
    gap: 2px;
    -webkit-app-region: no-drag;
  }

  .zoom-controls button {
    background: transparent;
    color: var(--text-muted);
    border: 1px solid var(--border);
    width: 28px;
    height: 28px;
    border-radius: 4px;
    font-size: 14px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s;
  }

  .zoom-controls button:hover {
    background: var(--surface-2);
    color: var(--text);
    border-color: var(--border-hover);
  }

  .zoom-level {
    min-width: 44px;
    text-align: center;
    font-size: 11px;
    font-family: var(--font-mono);
    color: var(--text-muted);
    user-select: none;
  }

  /* -- Status dot -------------------------------------- */
  .status-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--text-dim);
    flex-shrink: 0;
  }
  .status-dot.connected { background: #4ade80; }
  .status-dot.disconnected { background: #ef4444; }

  /* -- Toolbar button (Tree toggle, page size) --------- */
  .toolbar-btn {
    background: transparent;
    color: var(--text-muted);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 4px 10px;
    font-size: 11px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s;
    -webkit-app-region: no-drag;
    white-space: nowrap;
  }
  .toolbar-btn:hover {
    background: var(--surface-2);
    color: var(--text);
    border-color: var(--border-hover);
  }
  .toolbar-btn.active {
    background: var(--surface-2);
    color: var(--text);
    border-color: var(--accent);
  }

  /* -- Page size select -------------------------------- */
  #page-size-select {
    background: var(--bg);
    color: var(--text-muted);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 4px 6px;
    font-size: 11px;
    font-family: var(--font-sans);
    cursor: pointer;
    -webkit-app-region: no-drag;
  }
  #page-size-select:hover {
    border-color: var(--border-hover);
    color: var(--text);
  }
  .custom-size-inputs {
    display: none;
    align-items: center;
    gap: 4px;
    -webkit-app-region: no-drag;
  }
  .custom-size-inputs.visible { display: flex; }
  .custom-size-inputs input {
    width: 52px;
    background: var(--bg);
    color: var(--text);
    border: 1px solid var(--border);
    border-radius: 3px;
    padding: 3px 6px;
    font-size: 11px;
    font-family: var(--font-mono);
    text-align: center;
  }
  .custom-size-inputs input:focus {
    outline: none;
    border-color: var(--accent);
  }
  .custom-size-inputs span {
    color: var(--text-dim);
    font-size: 10px;
  }

  /* -- Left Sidebar ------------------------------------ */
  #left-sidebar {
    position: fixed;
    top: var(--toolbar-height);
    left: 0;
    bottom: 0;
    width: var(--left-sidebar-width);
    background: #111113;
    border-right: 1px solid var(--border);
    z-index: 150;
    transform: translateX(-100%);
    transition: transform 0.2s ease-out;
    display: flex;
    flex-direction: column;
    font-size: 12px;
    font-family: var(--font-mono);
  }
  #left-sidebar.open {
    transform: translateX(0);
  }

  .sidebar-tabs {
    display: flex;
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }
  .sidebar-tab {
    flex: 1;
    padding: 8px 12px;
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--text-dim);
    background: transparent;
    border: none;
    cursor: pointer;
    text-align: center;
    transition: color 0.15s;
    border-bottom: 2px solid transparent;
  }
  .sidebar-tab:hover { color: var(--text-muted); }
  .sidebar-tab.active {
    color: var(--text);
    border-bottom-color: var(--accent);
  }

  .sidebar-panel {
    flex: 1;
    overflow-y: auto;
    display: none;
  }
  .sidebar-panel.active { display: flex; flex-direction: column; }

  /* -- Component Tree ---------------------------------- */
  #component-tree {
    padding: 4px 0;
  }
  .tree-node {
    display: flex;
    align-items: center;
    padding: 2px 8px 2px 0;
    cursor: pointer;
    white-space: nowrap;
    transition: background 0.1s;
    user-select: none;
  }
  .tree-node:hover { background: #1c1c1e; }
  .tree-node.selected { background: #1e3a5f; color: #fff; }
  .tree-node .arrow {
    width: 16px;
    flex-shrink: 0;
    text-align: center;
    font-size: 10px;
    color: var(--text-dim);
    cursor: pointer;
  }
  .tree-node .arrow.has-children { color: var(--text-muted); }
  .tree-node .node-label {
    font-size: 12px;
  }
  .tree-node .text-preview {
    color: var(--text-dim);
    margin-left: 6px;
    font-size: 11px;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 140px;
  }
  .tree-node .dim-label {
    color: var(--text-dim);
    margin-left: 6px;
    font-size: 10px;
  }
  .tree-children { display: none; }
  .tree-children.expanded { display: block; }

  /* -- Data Editor ------------------------------------- */
  #data-panel {
    flex: 1;
    display: flex;
    flex-direction: column;
  }
  .data-toolbar {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }
  .data-save-btn {
    background: var(--surface-2);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 4px 12px;
    font-size: 11px;
    color: var(--text-muted);
    cursor: pointer;
    transition: all 0.15s;
  }
  .data-save-btn:hover {
    border-color: var(--border-hover);
    color: var(--text);
  }
  .data-feedback {
    font-size: 11px;
    color: #4ade80;
  }
  #data-editor {
    flex: 1;
    width: 100%;
    background: var(--bg);
    color: #e4e4e7;
    border: none;
    padding: 12px;
    font-size: 12px;
    font-family: var(--font-mono);
    resize: none;
    outline: none;
    line-height: 1.5;
    tab-size: 2;
  }
  #data-editor.error {
    border-top: 2px solid #ef4444;
  }
  .data-error {
    display: none;
    padding: 6px 12px;
    font-size: 11px;
    color: #fca5a5;
    background: #1c0a0a;
    border-top: 1px solid #3f1111;
    flex-shrink: 0;
  }
  .data-error.visible { display: block; }

  /* -- Canvas Container -------------------------------- */
  #canvas-container {
    position: fixed;
    top: var(--toolbar-height);
    left: 0;
    right: 0;
    bottom: 0;
    overflow: auto;
    transition: margin-left 0.2s ease-out, margin-right 0.2s ease-out;
  }

  #canvas-container.inspector-open {
    margin-right: var(--inspector-width);
  }
  #canvas-container.sidebar-open {
    margin-left: var(--left-sidebar-width);
  }

  #pages {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    padding: 32px 20px 60px;
    min-height: 100%;
  }

  .page-wrapper {
    position: relative;
    box-shadow: 0 2px 16px rgba(0,0,0,0.5), 0 0 0 1px rgba(255,255,255,0.03);
    border-radius: 2px;
    cursor: default;
  }

  .page-wrapper canvas.pdf-canvas {
    display: block;
    background: #fff;
    border-radius: 2px;
  }

  .page-wrapper canvas.overlay-canvas {
    position: absolute;
    top: 0;
    left: 0;
    pointer-events: none;
    border-radius: 2px;
  }

  .page-wrapper .hit-layer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    cursor: default;
  }

  /* -- Hover tooltip ----------------------------------- */
  #hover-tooltip {
    position: fixed;
    z-index: 300;
    pointer-events: none;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 3px 8px;
    font-size: 11px;
    font-family: var(--font-mono);
    color: var(--text-muted);
    white-space: nowrap;
    display: none;
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
  }

  /* -- Inspector Panel --------------------------------- */
  #inspector {
    position: fixed;
    top: var(--toolbar-height);
    right: 0;
    bottom: 0;
    width: var(--inspector-width);
    background: var(--surface);
    border-left: 1px solid var(--border);
    z-index: 150;
    overflow-y: auto;
    transform: translateX(100%);
    transition: transform 0.2s ease-out;
    font-size: 12px;
  }

  #inspector.open {
    transform: translateX(0);
  }

  .inspector-header {
    padding: 12px 16px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: space-between;
    position: sticky;
    top: 0;
    background: var(--surface);
    z-index: 1;
  }

  .breadcrumb {
    font-size: 11px;
    color: var(--text-dim);
    font-family: var(--font-mono);
    margin-bottom: 2px;
  }

  .inspector-header .node-label {
    font-weight: 600;
    font-size: 13px;
  }

  .inspector-header .node-dims {
    font-family: var(--font-mono);
    font-size: 11px;
    color: var(--text-dim);
  }

  .inspector-header .close-btn {
    background: transparent;
    border: none;
    color: var(--text-dim);
    cursor: pointer;
    font-size: 16px;
    padding: 2px 6px;
    border-radius: 4px;
    line-height: 1;
  }
  .inspector-header .close-btn:hover {
    background: var(--surface-2);
    color: var(--text);
  }

  /* -- Box Model Diagram ------------------------------- */
  .box-model {
    padding: 16px;
    border-bottom: 1px solid var(--border);
  }

  .box-model-title {
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--text-dim);
    margin-bottom: 12px;
  }

  .box-model-diagram {
    position: relative;
    width: 100%;
    aspect-ratio: 1.6;
    font-family: var(--font-mono);
    font-size: 10px;
    user-select: none;
  }

  .box-margin {
    position: absolute;
    inset: 0;
    background: rgba(251, 146, 60, 0.12);
    border: 1px dashed rgba(251, 146, 60, 0.4);
    border-radius: 4px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  .box-border-area {
    position: absolute;
    inset: 18%;
    background: rgba(96, 165, 250, 0.12);
    border: 1px solid rgba(96, 165, 250, 0.4);
    border-radius: 3px;
  }

  .box-padding {
    position: absolute;
    inset: 30%;
    background: rgba(74, 222, 128, 0.12);
    border: 1px dashed rgba(74, 222, 128, 0.4);
    border-radius: 2px;
  }

  .box-content {
    position: absolute;
    inset: 42%;
    background: rgba(96, 165, 250, 0.2);
    border-radius: 2px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-muted);
    font-size: 9px;
  }

  .box-label {
    position: absolute;
    color: var(--text-dim);
    font-size: 9px;
  }
  .box-label.top { top: 2px; left: 50%; transform: translateX(-50%); }
  .box-label.bottom { bottom: 2px; left: 50%; transform: translateX(-50%); }
  .box-label.left { left: 4px; top: 50%; transform: translateY(-50%); }
  .box-label.right { right: 4px; top: 50%; transform: translateY(-50%); }
  .box-label.margin-label { color: #fb923c; }
  .box-label.border-label { color: #60a5fa; }
  .box-label.padding-label { color: #4ade80; }

  /* -- Computed Styles --------------------------------- */
  .style-section {
    padding: 12px 16px;
    border-bottom: 1px solid var(--border);
  }

  .style-section-title {
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--text-dim);
    margin-bottom: 8px;
  }

  .style-row {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    padding: 2px 0;
    font-size: 11px;
  }

  .style-row .prop {
    color: var(--text-muted);
  }

  .style-row .val {
    font-family: var(--font-mono);
    color: var(--text);
    text-align: right;
  }

  .color-swatch {
    display: inline-block;
    width: 10px;
    height: 10px;
    border-radius: 2px;
    border: 1px solid var(--border);
    vertical-align: middle;
    margin-right: 4px;
  }

  /* -- Inspector Actions ------------------------------- */
  .inspector-actions {
    padding: 12px 16px;
  }

  .copy-style-btn {
    width: 100%;
    background: var(--surface-2);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 8px 12px;
    font-size: 12px;
    color: var(--text-muted);
    cursor: pointer;
    transition: all 0.15s;
  }

  .copy-style-btn:hover {
    border-color: var(--border-hover);
    color: var(--text);
  }

  /* -- Error Overlay ----------------------------------- */
  #error-overlay {
    display: none;
    position: fixed;
    top: var(--toolbar-height);
    left: 0;
    right: 0;
    z-index: 180;
    background: #450a0a;
    border-bottom: 1px solid #7f1d1d;
    color: #fca5a5;
    padding: 12px 20px;
    font-family: var(--font-mono);
    font-size: 12px;
    white-space: pre-wrap;
    word-break: break-word;
    max-height: 200px;
    overflow-y: auto;
  }

  #error-overlay .error-dismiss {
    position: absolute;
    top: 8px;
    right: 12px;
    background: transparent;
    border: none;
    color: #fca5a5;
    cursor: pointer;
    font-size: 14px;
    opacity: 0.6;
  }
  #error-overlay .error-dismiss:hover { opacity: 1; }

  /* -- Editor dropdown --------------------------------- */
  #editor-select {
    background: var(--bg);
    color: var(--text-muted);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 4px 6px;
    font-size: 11px;
    font-family: var(--font-sans);
    cursor: pointer;
    -webkit-app-region: no-drag;
  }
  #editor-select:hover {
    border-color: var(--border-hover);
    color: var(--text);
  }

  /* -- Source location in inspector -------------------- */
  .node-source {
    margin-top: 4px;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .source-path {
    font-family: var(--font-mono);
    font-size: 10px;
    color: var(--text-dim);
  }
  .open-editor-btn {
    background: var(--surface-2);
    border: 1px solid var(--border);
    border-radius: 3px;
    padding: 1px 6px;
    font-size: 10px;
    color: var(--text-muted);
    cursor: pointer;
    transition: all 0.15s;
  }
  .open-editor-btn:hover {
    border-color: var(--border-hover);
    color: var(--text);
  }

  /* -- Crossfade animation ----------------------------- */
  .page-wrapper.fading {
    opacity: 0;
    transition: opacity 0.15s ease;
  }
  .page-wrapper.visible {
    opacity: 1;
    transition: opacity 0.15s ease;
  }
</style>
</head>
<body>

<div id="toolbar">
  <div class="toolbar-group">
    <div class="status-dot" id="status-dot"></div>
    <div class="wordmark">forme <span>preview</span></div>
  </div>

  <div class="toolbar-separator"></div>

  <button class="toolbar-btn" id="tree-toggle" title="Toggle component tree (T)">Tree</button>

  <div class="toolbar-separator"></div>

  <div class="segmented-control" id="mode-control">
    <button data-mode="preview" class="active">Preview <span class="shortcut">1</span></button>
    <button data-mode="layout">Layout <span class="shortcut">2</span></button>
    <button data-mode="margins">Margins <span class="shortcut">3</span></button>
    <button data-mode="breaks">Breaks <span class="shortcut">4</span></button>
  </div>

  <div class="toolbar-separator"></div>

  <div class="toolbar-group">
    <select id="page-size-select" title="Page size override">
      <option value="default">Default</option>
      <option value="letter">Letter (612 x 792)</option>
      <option value="a4">A4 (595 x 842)</option>
      <option value="legal">Legal (612 x 1008)</option>
      <option value="tabloid">Tabloid (792 x 1224)</option>
      <option value="a3">A3 (842 x 1191)</option>
      <option value="a5">A5 (420 x 595)</option>
      <option value="custom">Custom...</option>
    </select>
    <div class="custom-size-inputs" id="custom-size-inputs">
      <input type="number" id="custom-width" placeholder="W" value="612" min="72" max="4000">
      <span>x</span>
      <input type="number" id="custom-height" placeholder="H" value="792" min="72" max="4000">
      <span>pt</span>
    </div>
  </div>

  <div class="toolbar-spacer"></div>

  <div class="badge render-time" id="render-badge" style="display:none">
    <span id="render-time">0ms</span>
  </div>
  <div class="badge page-count" id="page-badge" style="display:none">
    <span id="page-count">0</span> pages
  </div>

  <div class="toolbar-separator"></div>

  <div class="zoom-controls">
    <button id="zoom-out" title="Zoom out (Cmd -)">&#x2212;</button>
    <span class="zoom-level" id="zoom-level">100%</span>
    <button id="zoom-in" title="Zoom in (Cmd +)">+</button>
    <button id="zoom-fit" title="Fit to window (Cmd 0)" style="font-size:11px; width:auto; padding: 0 8px;">Fit</button>
  </div>

  <div class="toolbar-separator"></div>
  <div class="toolbar-group">
    <select id="editor-select" title="Editor for Open in Editor">
      <option value="vscode">VS Code</option>
      <option value="cursor">Cursor</option>
      <option value="webstorm">WebStorm</option>
    </select>
  </div>
</div>

<div id="error-overlay">
  <button class="error-dismiss" id="error-dismiss">&times;</button>
</div>

<div id="left-sidebar">
  <div class="sidebar-tabs" id="sidebar-tabs">
    <button class="sidebar-tab active" data-tab="components">Components</button>
    <button class="sidebar-tab" data-tab="data" id="data-tab-btn" style="display:none">Data</button>
  </div>
  <div class="sidebar-panel active" id="components-panel">
    <div id="component-tree"></div>
  </div>
  <div class="sidebar-panel" id="data-panel-container">
    <div id="data-panel">
      <div class="data-toolbar">
        <button class="data-save-btn" id="data-save-btn">Save</button>
        <span class="data-feedback" id="data-feedback"></span>
      </div>
      <textarea id="data-editor" spellcheck="false"></textarea>
      <div class="data-error" id="data-error"></div>
    </div>
  </div>
</div>

<div id="canvas-container">
  <div id="pages"></div>
</div>

<div id="hover-tooltip"></div>

<div id="inspector">
  <div class="inspector-header">
    <div>
      <div class="breadcrumb" id="inspector-breadcrumb"></div>
      <div class="node-label" id="inspector-label">View</div>
      <div class="node-dims" id="inspector-dims">0 x 0 at (0, 0)</div>
      <div class="node-source" id="inspector-source" style="display:none"></div>
    </div>
    <button class="close-btn" id="inspector-close">&times;</button>
  </div>

  <div class="box-model">
    <div class="box-model-title">Box Model</div>
    <div class="box-model-diagram" id="box-model-diagram">
      <div class="box-margin">
        <span class="box-label top margin-label" id="bm-margin-top">0</span>
        <span class="box-label bottom margin-label" id="bm-margin-bottom">0</span>
        <span class="box-label left margin-label" id="bm-margin-left">0</span>
        <span class="box-label right margin-label" id="bm-margin-right">0</span>
      </div>
      <div class="box-border-area">
        <span class="box-label top border-label" id="bm-border-top">0</span>
        <span class="box-label bottom border-label" id="bm-border-bottom">0</span>
        <span class="box-label left border-label" id="bm-border-left">0</span>
        <span class="box-label right border-label" id="bm-border-right">0</span>
      </div>
      <div class="box-padding">
        <span class="box-label top padding-label" id="bm-padding-top">0</span>
        <span class="box-label bottom padding-label" id="bm-padding-bottom">0</span>
        <span class="box-label left padding-label" id="bm-padding-left">0</span>
        <span class="box-label right padding-label" id="bm-padding-right">0</span>
      </div>
      <div class="box-content" id="bm-content">0 x 0</div>
    </div>
  </div>

  <div id="inspector-styles"></div>
  <div class="inspector-actions" id="inspector-actions"></div>
</div>

<script type="module">
  // -- PDF.js Setup ------------------------------------------------
  const PDFJS_CDN = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.9.155/pdf.min.mjs';
  const PDFJS_WORKER_CDN = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.9.155/pdf.worker.min.mjs';

  const pdfjsLib = await import(PDFJS_CDN);
  pdfjsLib.GlobalWorkerOptions.workerSrc = PDFJS_WORKER_CDN;

  // -- State -------------------------------------------------------
  const ZOOM_LEVELS = [0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 2.0];
  let currentZoomIndex = 3; // 100%
  let currentZoom = 1.0;
  let currentMode = 'preview'; // preview | layout | margins | breaks
  let layoutData = null;
  let selectedElement = null;
  let selectedAncestors = [];
  let selectedAncestorElements = [];
  let selectedPageIdx = -1;
  let selectedPath = null; // index path like [0, 2, 1]
  let inspectorOpen = false;
  let sidebarOpen = localStorage.getItem('forme-sidebar') !== 'false';
  let activeTab = 'components';
  let hasDataFile = false;
  let wsRef = null;

  // -- DOM refs ----------------------------------------------------
  const pagesEl = document.getElementById('pages');
  const containerEl = document.getElementById('canvas-container');
  const errorEl = document.getElementById('error-overlay');
  const renderTimeEl = document.getElementById('render-time');
  const renderBadge = document.getElementById('render-badge');
  const pageCountEl = document.getElementById('page-count');
  const pageBadge = document.getElementById('page-badge');
  const statusDot = document.getElementById('status-dot');
  const zoomLevelEl = document.getElementById('zoom-level');
  const modeControl = document.getElementById('mode-control');
  const inspectorEl = document.getElementById('inspector');
  const inspectorLabel = document.getElementById('inspector-label');
  const inspectorDims = document.getElementById('inspector-dims');
  const inspectorStyles = document.getElementById('inspector-styles');
  const inspectorBreadcrumb = document.getElementById('inspector-breadcrumb');
  const inspectorActions = document.getElementById('inspector-actions');
  const tooltip = document.getElementById('hover-tooltip');
  const leftSidebar = document.getElementById('left-sidebar');
  const treeToggle = document.getElementById('tree-toggle');
  const componentTree = document.getElementById('component-tree');
  const sidebarTabs = document.getElementById('sidebar-tabs');
  const dataTabBtn = document.getElementById('data-tab-btn');
  const componentsPanel = document.getElementById('components-panel');
  const dataPanelContainer = document.getElementById('data-panel-container');
  const dataEditor = document.getElementById('data-editor');
  const dataError = document.getElementById('data-error');
  const dataSaveBtn = document.getElementById('data-save-btn');
  const dataFeedback = document.getElementById('data-feedback');

  // -- Left Sidebar Toggle -----------------------------------------
  function setSidebarOpen(open) {
    sidebarOpen = open;
    leftSidebar.classList.toggle('open', open);
    containerEl.classList.toggle('sidebar-open', open);
    treeToggle.classList.toggle('active', open);
    localStorage.setItem('forme-sidebar', String(open));
  }

  treeToggle.addEventListener('click', () => setSidebarOpen(!sidebarOpen));
  setSidebarOpen(sidebarOpen);

  // -- Sidebar Tabs ------------------------------------------------
  function setActiveTab(tab) {
    activeTab = tab;
    sidebarTabs.querySelectorAll('.sidebar-tab').forEach(t => {
      t.classList.toggle('active', t.dataset.tab === tab);
    });
    componentsPanel.classList.toggle('active', tab === 'components');
    dataPanelContainer.classList.toggle('active', tab === 'data');
  }

  sidebarTabs.addEventListener('click', (e) => {
    const tab = e.target.closest('.sidebar-tab');
    if (tab && tab.dataset.tab) setActiveTab(tab.dataset.tab);
  });

  // -- Mode Toggle -------------------------------------------------
  function setMode(mode) {
    currentMode = mode;
    modeControl.querySelectorAll('button').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.mode === mode);
    });
    drawOverlays();
  }

  modeControl.addEventListener('click', (e) => {
    const btn = e.target.closest('button');
    if (btn && btn.dataset.mode) setMode(btn.dataset.mode);
  });

  // -- Page Size Switcher ------------------------------------------
  const PAGE_SIZES = {
    letter: { width: 612, height: 792 },
    a4:     { width: 595, height: 842 },
    legal:  { width: 612, height: 1008 },
    tabloid:{ width: 792, height: 1224 },
    a3:     { width: 842, height: 1191 },
    a5:     { width: 420, height: 595 },
  };

  const pageSizeSelect = document.getElementById('page-size-select');
  const customSizeInputs = document.getElementById('custom-size-inputs');
  const customWidthInput = document.getElementById('custom-width');
  const customHeightInput = document.getElementById('custom-height');

  // Restore from localStorage
  const savedPageSize = localStorage.getItem('forme-pagesize');
  if (savedPageSize) {
    pageSizeSelect.value = savedPageSize;
    if (savedPageSize === 'custom') {
      customSizeInputs.classList.add('visible');
      const savedW = localStorage.getItem('forme-pagesize-w');
      const savedH = localStorage.getItem('forme-pagesize-h');
      if (savedW) customWidthInput.value = savedW;
      if (savedH) customHeightInput.value = savedH;
    }
  }

  pageSizeSelect.addEventListener('change', () => {
    const val = pageSizeSelect.value;
    localStorage.setItem('forme-pagesize', val);
    customSizeInputs.classList.toggle('visible', val === 'custom');

    if (val === 'default') {
      sendWs({ type: 'clearPageSize' });
    } else if (val === 'custom') {
      applyCustomSize();
    } else if (PAGE_SIZES[val]) {
      const { width, height } = PAGE_SIZES[val];
      sendWs({ type: 'setPageSize', width, height });
    }
  });

  function applyCustomSize() {
    const w = parseInt(customWidthInput.value, 10);
    const h = parseInt(customHeightInput.value, 10);
    if (w > 0 && h > 0) {
      localStorage.setItem('forme-pagesize-w', String(w));
      localStorage.setItem('forme-pagesize-h', String(h));
      sendWs({ type: 'setPageSize', width: w, height: h });
    }
  }

  customWidthInput.addEventListener('change', applyCustomSize);
  customHeightInput.addEventListener('change', applyCustomSize);
  customWidthInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') applyCustomSize(); });
  customHeightInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') applyCustomSize(); });

  // Re-send page size override on reconnect
  function resendPageSizeOverride() {
    const val = pageSizeSelect.value;
    if (val === 'default') return;
    if (val === 'custom') {
      applyCustomSize();
    } else if (PAGE_SIZES[val]) {
      const { width, height } = PAGE_SIZES[val];
      sendWs({ type: 'setPageSize', width, height });
    }
  }

  // -- Zoom --------------------------------------------------------
  function setZoom(level) {
    currentZoom = level;
    let closest = 0;
    let minDist = Infinity;
    ZOOM_LEVELS.forEach((z, i) => {
      const d = Math.abs(z - level);
      if (d < minDist) { minDist = d; closest = i; }
    });
    currentZoomIndex = closest;
    zoomLevelEl.textContent = Math.round(currentZoom * 100) + '%';
  }

  function zoomIn() {
    if (currentZoomIndex < ZOOM_LEVELS.length - 1) {
      currentZoomIndex++;
      setZoom(ZOOM_LEVELS[currentZoomIndex]);
      reRenderPages();
    }
  }

  function zoomOut() {
    if (currentZoomIndex > 0) {
      currentZoomIndex--;
      setZoom(ZOOM_LEVELS[currentZoomIndex]);
      reRenderPages();
    }
  }

  function zoomToFit() {
    if (!layoutData || !layoutData.pages.length) return;
    const page = layoutData.pages[0];
    const availW = containerEl.clientWidth - 80;
    const availH = containerEl.clientHeight - 100;
    const fitW = availW / page.width;
    const fitH = availH / page.height;
    const fit = Math.min(fitW, fitH, 2.0);
    setZoom(Math.round(fit * 100) / 100);
    reRenderPages();
  }

  document.getElementById('zoom-in').addEventListener('click', zoomIn);
  document.getElementById('zoom-out').addEventListener('click', zoomOut);
  document.getElementById('zoom-fit').addEventListener('click', zoomToFit);

  // -- Inspector ---------------------------------------------------
  function openInspector(element, pageIdx) {
    selectedElement = element;
    selectedPageIdx = pageIdx;
    inspectorOpen = true;
    inspectorEl.classList.add('open');
    containerEl.classList.add('inspector-open');
    updateInspector();
    drawOverlays();
  }

  function closeInspector() {
    selectedElement = null;
    selectedAncestors = [];
    selectedAncestorElements = [];
    selectedPageIdx = -1;
    selectedPath = null;
    inspectorOpen = false;
    inspectorEl.classList.remove('open');
    containerEl.classList.remove('inspector-open');
    updateTreeSelection(null);
    drawOverlays();
  }

  document.getElementById('inspector-close').addEventListener('click', closeInspector);
  document.getElementById('error-dismiss').addEventListener('click', () => {
    errorEl.style.display = 'none';
  });

  function updateInspector() {
    if (!selectedElement) return;
    const el = selectedElement;
    const s = el.style;

    // Breadcrumb
    if (selectedAncestors.length > 0) {
      inspectorBreadcrumb.textContent = selectedAncestors.join(' > ');
      inspectorBreadcrumb.style.display = '';
    } else {
      inspectorBreadcrumb.textContent = '';
      inspectorBreadcrumb.style.display = 'none';
    }

    // Header
    const nodeTypeColors = {
      View: '#3b82f6', Text: '#eab308', Image: '#a855f7',
      Table: '#22c55e', TableRow: '#22c55e', TableCell: '#22c55e',
      FixedHeader: '#ef4444', FixedFooter: '#ef4444',
    };
    const color = nodeTypeColors[el.nodeType] || '#a1a1aa';
    inspectorLabel.innerHTML = `<span style="color:${color}">${el.nodeType}</span>`;
    inspectorDims.textContent = `${fmt(el.width)} \u00d7 ${fmt(el.height)} at (${fmt(el.x)}, ${fmt(el.y)})`;

    // Source location (bubble up from ancestors if element doesn't have one)
    const sourceEl = document.getElementById('inspector-source');
    let sl = el.sourceLocation;
    if (!sl) {
      for (let i = selectedAncestorElements.length - 1; i >= 0; i--) {
        if (selectedAncestorElements[i].sourceLocation) {
          sl = selectedAncestorElements[i].sourceLocation;
          break;
        }
      }
    }
    if (sl) {
      const fileName = sl.file.split('/').pop();
      sourceEl.innerHTML = `<span class="source-path">${fileName}:${sl.line}:${sl.column}</span> <button class="open-editor-btn" id="open-editor-btn">Open</button>`;
      sourceEl.style.display = '';
      document.getElementById('open-editor-btn').addEventListener('click', () => openInEditor(sl));
    } else {
      sourceEl.style.display = 'none';
    }

    // Box model
    setText('bm-margin-top', fmt(s.margin.top));
    setText('bm-margin-bottom', fmt(s.margin.bottom));
    setText('bm-margin-left', fmt(s.margin.left));
    setText('bm-margin-right', fmt(s.margin.right));
    setText('bm-border-top', fmt(s.borderWidth.top));
    setText('bm-border-bottom', fmt(s.borderWidth.bottom));
    setText('bm-border-left', fmt(s.borderWidth.left));
    setText('bm-border-right', fmt(s.borderWidth.right));
    setText('bm-padding-top', fmt(s.padding.top));
    setText('bm-padding-bottom', fmt(s.padding.bottom));
    setText('bm-padding-left', fmt(s.padding.left));
    setText('bm-padding-right', fmt(s.padding.right));

    const cw = el.width - s.padding.left - s.padding.right - s.borderWidth.left - s.borderWidth.right;
    const ch = el.height - s.padding.top - s.padding.bottom - s.borderWidth.top - s.borderWidth.bottom;
    setText('bm-content', `${fmt(Math.max(0, cw))} \u00d7 ${fmt(Math.max(0, ch))}`);

    // Computed styles
    let html = '';

    const sizeProps = [];
    if (s.width != null) sizeProps.push(['width', s.width + 'pt']);
    if (s.height != null) sizeProps.push(['height', s.height + 'pt']);
    if (s.minWidth != null) sizeProps.push(['min-width', fmt(s.minWidth) + 'pt']);
    if (s.minHeight != null) sizeProps.push(['min-height', fmt(s.minHeight) + 'pt']);
    if (s.maxWidth != null) sizeProps.push(['max-width', fmt(s.maxWidth) + 'pt']);
    if (s.maxHeight != null) sizeProps.push(['max-height', fmt(s.maxHeight) + 'pt']);
    if (sizeProps.length) {
      html += renderStyleSection('Sizing', sizeProps);
    }

    const posProps = [];
    if (s.position && s.position !== 'Relative') {
      posProps.push(['position', s.position.toLowerCase()]);
      if (s.top != null) posProps.push(['top', fmt(s.top) + 'pt']);
      if (s.right != null) posProps.push(['right', fmt(s.right) + 'pt']);
      if (s.bottom != null) posProps.push(['bottom', fmt(s.bottom) + 'pt']);
      if (s.left != null) posProps.push(['left', fmt(s.left) + 'pt']);
    }
    if (posProps.length) {
      html += renderStyleSection('Positioning', posProps);
    }

    const layoutProps = [];
    if (s.flexDirection !== 'Column') layoutProps.push(['flex-direction', s.flexDirection]);
    if (s.justifyContent !== 'FlexStart') layoutProps.push(['justify-content', s.justifyContent]);
    if (s.alignItems !== 'Stretch') layoutProps.push(['align-items', s.alignItems]);
    if (s.alignSelf) layoutProps.push(['align-self', s.alignSelf]);
    if (s.flexWrap !== 'NoWrap') layoutProps.push(['flex-wrap', s.flexWrap]);
    if (s.flexGrow > 0) layoutProps.push(['flex-grow', String(s.flexGrow)]);
    if (s.flexShrink !== 1) layoutProps.push(['flex-shrink', String(s.flexShrink)]);
    if (s.flexBasis != null) layoutProps.push(['flex-basis', s.flexBasis + 'pt']);
    if (s.gap > 0) layoutProps.push(['gap', fmt(s.gap) + 'pt']);
    if (s.rowGap > 0 && s.rowGap !== s.gap) layoutProps.push(['row-gap', fmt(s.rowGap) + 'pt']);
    if (s.columnGap > 0 && s.columnGap !== s.gap) layoutProps.push(['column-gap', fmt(s.columnGap) + 'pt']);
    if (layoutProps.length) {
      html += renderStyleSection('Layout', layoutProps);
    }

    const spacingProps = [];
    const marginStr = edgesShorthand(s.margin);
    const paddingStr = edgesShorthand(s.padding);
    const borderStr = edgesShorthand(s.borderWidth);
    if (marginStr !== '0') spacingProps.push(['margin', marginStr]);
    if (paddingStr !== '0') spacingProps.push(['padding', paddingStr]);
    if (borderStr !== '0') spacingProps.push(['border-width', borderStr]);
    if (spacingProps.length) {
      html += renderStyleSection('Spacing', spacingProps);
    }

    const typoProps = [];
    typoProps.push(['font-family', s.fontFamily]);
    typoProps.push(['font-size', fmt(s.fontSize) + 'pt']);
    if (s.fontWeight !== 400) typoProps.push(['font-weight', String(s.fontWeight)]);
    if (s.fontStyle !== 'Normal') typoProps.push(['font-style', s.fontStyle]);
    if (s.lineHeight !== 1.4) typoProps.push(['line-height', fmt(s.lineHeight)]);
    if (s.textAlign !== 'Left') typoProps.push(['text-align', s.textAlign]);
    if (s.letterSpacing !== 0) typoProps.push(['letter-spacing', fmt(s.letterSpacing) + 'pt']);
    if (s.textDecoration !== 'None') typoProps.push(['text-decoration', s.textDecoration.toLowerCase()]);
    if (s.textTransform !== 'None') typoProps.push(['text-transform', s.textTransform.toLowerCase()]);
    html += renderStyleSection('Typography', typoProps);

    const visualProps = [];
    visualProps.push(['color', colorHtml(s.color)]);
    if (s.backgroundColor) visualProps.push(['background', colorHtml(s.backgroundColor)]);
    if (s.opacity < 1) visualProps.push(['opacity', fmt(s.opacity)]);
    const radiusStr = cornerShorthand(s.borderRadius);
    if (radiusStr !== '0') visualProps.push(['border-radius', radiusStr]);
    html += renderStyleSection('Background & Border', visualProps);

    // Link & Bookmark info
    const linkProps = [];
    if (el.href) linkProps.push(['href', escapeHtml(el.href)]);
    if (el.bookmark) linkProps.push(['bookmark', escapeHtml(el.bookmark)]);
    if (linkProps.length) {
      html += renderStyleSection('Link & Bookmark', linkProps);
    }

    const pageProps = [];
    if (s.breakable) pageProps.push(['breakable', 'true']);
    if (s.breakBefore) pageProps.push(['break-before', 'true']);
    if (s.minWidowLines !== 2) pageProps.push(['min-widow-lines', String(s.minWidowLines)]);
    if (s.minOrphanLines !== 2) pageProps.push(['min-orphan-lines', String(s.minOrphanLines)]);
    if (pageProps.length) {
      html += renderStyleSection('Page Behavior', pageProps);
    }

    inspectorStyles.innerHTML = html;

    // Copy Style button
    const styleStr = buildJsxStyleString(s);
    if (styleStr) {
      inspectorActions.innerHTML = `<button class="copy-style-btn" id="copy-style-btn">Copy Style</button>`;
      document.getElementById('copy-style-btn').addEventListener('click', () => {
        navigator.clipboard.writeText(styleStr);
        const btn = document.getElementById('copy-style-btn');
        btn.textContent = 'Copied!';
        setTimeout(() => { btn.textContent = 'Copy Style'; }, 1500);
      });
    } else {
      inspectorActions.innerHTML = '';
    }
  }

  function renderStyleSection(title, props) {
    let html = `<div class="style-section"><div class="style-section-title">${title}</div>`;
    for (const [prop, val] of props) {
      html += `<div class="style-row"><span class="prop">${prop}</span><span class="val">${val}</span></div>`;
    }
    html += '</div>';
    return html;
  }

  // -- Helpers -----------------------------------------------------
  function setText(id, text) { document.getElementById(id).textContent = text; }
  function fmt(n) { return Number.isInteger(n) ? String(n) : n.toFixed(1).replace(/\.0$/, ''); }
  function escapeHtml(s) { return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }

  function colorToHex(c) {
    if (!c) return 'transparent';
    const r = Math.round(c.r * 255).toString(16).padStart(2, '0');
    const g = Math.round(c.g * 255).toString(16).padStart(2, '0');
    const b = Math.round(c.b * 255).toString(16).padStart(2, '0');
    return `#${r}${g}${b}`;
  }

  function colorHtml(c) {
    const hex = colorToHex(c);
    return `<span class="color-swatch" style="background:${hex}"></span>${hex}`;
  }

  function edgesShorthand(e) {
    const t = fmt(e.top), r = fmt(e.right), b = fmt(e.bottom), l = fmt(e.left);
    if (t === r && r === b && b === l) return t;
    if (t === b && l === r) return `${t} ${r}`;
    return `${t} ${r} ${b} ${l}`;
  }

  function cornerShorthand(c) {
    const tl = fmt(c.top_left), tr = fmt(c.top_right), br = fmt(c.bottom_right), bl = fmt(c.bottom_left);
    if (tl === tr && tr === br && br === bl) return tl;
    return `${tl} ${tr} ${br} ${bl}`;
  }

  // -- JSX Style Builder -------------------------------------------
  function buildJsxStyleString(s) {
    const enumMap = {
      'Column': 'column', 'Row': 'row',
      'FlexStart': 'flex-start', 'FlexEnd': 'flex-end',
      'Center': 'center', 'SpaceBetween': 'space-between',
      'SpaceAround': 'space-around', 'SpaceEvenly': 'space-evenly',
      'Stretch': 'stretch', 'Baseline': 'baseline',
      'NoWrap': 'nowrap', 'Wrap': 'wrap',
      'Normal': 'normal', 'Italic': 'italic',
      'Left': 'left', 'Right': 'right', 'Justify': 'justify',
      'None': 'none', 'Underline': 'underline', 'LineThrough': 'line-through',
      'Uppercase': 'uppercase', 'Lowercase': 'lowercase', 'Capitalize': 'capitalize',
    };
    function mapEnum(v) { return enumMap[v] || v; }

    function colorEq(c, r, g, b) {
      return c && Math.abs(c.r - r) < 0.001 && Math.abs(c.g - g) < 0.001 && Math.abs(c.b - b) < 0.001;
    }

    function edgesAllZero(e) { return e.top === 0 && e.right === 0 && e.bottom === 0 && e.left === 0; }
    function edgesUniform(e) { return e.top === e.right && e.right === e.bottom && e.bottom === e.left; }
    function cornersAllZero(c) { return c.top_left === 0 && c.top_right === 0 && c.bottom_right === 0 && c.bottom_left === 0; }
    function cornersUniform(c) { return c.top_left === c.top_right && c.top_right === c.bottom_right && c.bottom_right === c.bottom_left; }

    function fmtEdges(e) {
      if (edgesUniform(e)) return String(e.top);
      return `{ top: ${e.top}, right: ${e.right}, bottom: ${e.bottom}, left: ${e.left} }`;
    }
    function fmtCorners(c) {
      if (cornersUniform(c)) return String(c.top_left);
      return `{ topLeft: ${c.top_left}, topRight: ${c.top_right}, bottomRight: ${c.bottom_right}, bottomLeft: ${c.bottom_left} }`;
    }

    const props = [];

    if (s.width != null) props.push(`width: ${s.width}`);
    if (s.height != null) props.push(`height: ${s.height}`);
    if (s.minWidth != null) props.push(`minWidth: ${s.minWidth}`);
    if (s.minHeight != null) props.push(`minHeight: ${s.minHeight}`);
    if (s.maxWidth != null) props.push(`maxWidth: ${s.maxWidth}`);
    if (s.maxHeight != null) props.push(`maxHeight: ${s.maxHeight}`);
    if (s.flexDirection !== 'Column') props.push(`flexDirection: '${mapEnum(s.flexDirection)}'`);
    if (s.justifyContent !== 'FlexStart') props.push(`justifyContent: '${mapEnum(s.justifyContent)}'`);
    if (s.alignItems !== 'Stretch') props.push(`alignItems: '${mapEnum(s.alignItems)}'`);
    if (s.alignSelf) props.push(`alignSelf: '${mapEnum(s.alignSelf)}'`);
    if (s.flexWrap !== 'NoWrap') props.push(`flexWrap: '${mapEnum(s.flexWrap)}'`);
    if (s.flexGrow > 0) props.push(`flexGrow: ${s.flexGrow}`);
    if (s.flexShrink !== 1) props.push(`flexShrink: ${s.flexShrink}`);
    if (s.flexBasis != null) props.push(`flexBasis: ${s.flexBasis}`);
    if (s.gap > 0) props.push(`gap: ${s.gap}`);
    if (s.rowGap > 0) props.push(`rowGap: ${s.rowGap}`);
    if (s.columnGap > 0) props.push(`columnGap: ${s.columnGap}`);

    if (!edgesAllZero(s.margin)) props.push(`margin: ${fmtEdges(s.margin)}`);
    if (!edgesAllZero(s.padding)) props.push(`padding: ${fmtEdges(s.padding)}`);
    if (!edgesAllZero(s.borderWidth)) props.push(`borderWidth: ${fmtEdges(s.borderWidth)}`);

    if (s.fontFamily !== 'Helvetica') props.push(`fontFamily: '${s.fontFamily}'`);
    if (s.fontSize !== 12) props.push(`fontSize: ${s.fontSize}`);
    if (s.fontWeight !== 400) props.push(`fontWeight: ${s.fontWeight}`);
    if (s.fontStyle !== 'Normal') props.push(`fontStyle: '${mapEnum(s.fontStyle)}'`);
    if (s.lineHeight !== 1.4) props.push(`lineHeight: ${s.lineHeight}`);
    if (s.textAlign !== 'Left') props.push(`textAlign: '${mapEnum(s.textAlign)}'`);
    if (s.letterSpacing !== 0) props.push(`letterSpacing: ${s.letterSpacing}`);
    if (s.textDecoration !== 'None') props.push(`textDecoration: '${mapEnum(s.textDecoration)}'`);
    if (s.textTransform !== 'None') props.push(`textTransform: '${mapEnum(s.textTransform)}'`);

    if (s.opacity < 1) props.push(`opacity: ${s.opacity}`);
    if (!colorEq(s.color, 0, 0, 0)) props.push(`color: '${colorToHex(s.color)}'`);
    if (s.backgroundColor) props.push(`backgroundColor: '${colorToHex(s.backgroundColor)}'`);
    if (!cornersAllZero(s.borderRadius)) props.push(`borderRadius: ${fmtCorners(s.borderRadius)}`);

    if (props.length === 0) return null;
    return `{ ${props.join(', ')} }`;
  }

  // -- Editor Integration ------------------------------------------
  const editorSelect = document.getElementById('editor-select');
  const savedEditor = localStorage.getItem('forme-editor');
  if (savedEditor && editorSelect.querySelector(`option[value="${savedEditor}"]`)) {
    editorSelect.value = savedEditor;
  }
  editorSelect.addEventListener('change', () => {
    localStorage.setItem('forme-editor', editorSelect.value);
  });

  const editorUrls = {
    vscode:    (s) => `vscode://file/${s.file}:${s.line}:${s.column}`,
    cursor:    (s) => `cursor://file/${s.file}:${s.line}:${s.column}`,
    webstorm:  (s) => `webstorm://open?file=${encodeURIComponent(s.file)}&line=${s.line}&column=${s.column}`,
  };

  function openInEditor(source) {
    const editor = editorSelect.value;
    const url = editorUrls[editor](source);
    window.open(url, '_blank');
  }

  // -- Component Tree ----------------------------------------------
  const NODE_TYPE_COLORS = {
    View: '#3b82f6',
    Text: '#eab308',
    TextLine: '#eab308',
    Image: '#a855f7',
    Table: '#22c55e',
    TableRow: '#10b981',
    TableCell: '#34d399',
    FixedHeader: '#ef4444',
    FixedFooter: '#ef4444',
    Page: '#a1a1aa',
    Rect: '#6b7280',
    None: '#6b7280',
  };

  function renderComponentTree() {
    if (!layoutData) {
      componentTree.innerHTML = '<div style="padding:12px;color:var(--text-dim)">No layout data</div>';
      return;
    }

    let html = '';
    for (let pi = 0; pi < layoutData.pages.length; pi++) {
      const page = layoutData.pages[pi];
      html += renderTreeNode({
        nodeType: 'Page',
        width: page.width,
        height: page.height,
        children: page.elements,
      }, [pi], 0, true);
    }
    componentTree.innerHTML = html;

    // Restore expanded state from defaults
    componentTree.querySelectorAll('.tree-children').forEach(el => {
      const depth = parseInt(el.dataset.depth, 10);
      if (depth < 2) {
        el.classList.add('expanded');
        const arrow = el.previousElementSibling?.querySelector('.arrow');
        if (arrow && arrow.classList.contains('has-children')) {
          arrow.textContent = '\u25BE';
        }
      }
    });

    // Restore selection
    if (selectedPath) {
      updateTreeSelection(selectedPath);
    }
  }

  function renderTreeNode(el, path, depth, isExpanded) {
    const pathStr = JSON.stringify(path);
    const hasChildren = el.children && el.children.length > 0;
    const color = NODE_TYPE_COLORS[el.nodeType] || '#6b7280';
    const indent = depth * 16;

    let extra = '';
    if (el.nodeType === 'TextLine' && el.textContent) {
      const preview = el.textContent.length > 30
        ? el.textContent.substring(0, 30) + '...'
        : el.textContent;
      const escaped = preview.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
      extra = `<span class="text-preview">"${escaped}"</span>`;
    } else if (el.nodeType === 'Page' && el.width) {
      extra = `<span class="dim-label">${fmt(el.width)} x ${fmt(el.height)}</span>`;
    }

    const arrowChar = hasChildren ? (isExpanded ? '\u25BE' : '\u25B8') : '';
    const arrowClass = hasChildren ? 'arrow has-children' : 'arrow';

    let html = `<div class="tree-node" data-path='${pathStr}' style="padding-left:${indent + 4}px">`;
    html += `<span class="${arrowClass}" data-toggle='${pathStr}'>${arrowChar}</span>`;
    html += `<span class="node-label" style="color:${color}">${el.nodeType}</span>`;
    html += extra;
    html += `</div>`;

    if (hasChildren) {
      html += `<div class="tree-children" data-depth="${depth}" data-path='${pathStr}'>`;
      for (let ci = 0; ci < el.children.length; ci++) {
        const childPath = [...path, ci];
        html += renderTreeNode(el.children[ci], childPath, depth + 1, false);
      }
      html += `</div>`;
    }

    return html;
  }

  // Tree click handlers (delegated)
  componentTree.addEventListener('click', (e) => {
    // Toggle expand/collapse
    const arrow = e.target.closest('.arrow.has-children');
    if (arrow) {
      const pathStr = arrow.dataset.toggle;
      const children = componentTree.querySelector(`.tree-children[data-path='${pathStr}']`);
      if (children) {
        const isExpanded = children.classList.toggle('expanded');
        arrow.textContent = isExpanded ? '\u25BE' : '\u25B8';
      }
      return;
    }

    // Select node
    const node = e.target.closest('.tree-node');
    if (node) {
      const path = JSON.parse(node.dataset.path);
      selectByPath(path);
    }
  });

  // Tree hover handlers (delegated)
  componentTree.addEventListener('mouseover', (e) => {
    const node = e.target.closest('.tree-node');
    if (!node) return;
    const path = JSON.parse(node.dataset.path);
    const resolved = resolveElementByPath(path);
    if (resolved) {
      drawOverlays(resolved.element, resolved.pageIdx);
    }
  });

  componentTree.addEventListener('mouseleave', () => {
    drawOverlays();
  });

  function selectByPath(path) {
    selectedPath = path;
    const resolved = resolveElementByPath(path);
    if (!resolved) return;

    const { element, pageIdx, ancestors, ancestorElements } = resolved;
    selectedAncestors = ancestors;
    selectedAncestorElements = ancestorElements;
    openInspector(element, pageIdx);
    updateTreeSelection(path);

    // Scroll PDF to show element
    scrollToElement(element, pageIdx);
  }

  function resolveElementByPath(path) {
    if (!layoutData || !path || path.length === 0) return null;

    const pageIdx = path[0];
    const page = layoutData.pages[pageIdx];
    if (!page) return null;

    if (path.length === 1) {
      // Page-level selection
      return {
        element: { nodeType: 'Page', x: 0, y: 0, width: page.width, height: page.height,
                   style: page.elements[0]?.style || {}, children: page.elements },
        pageIdx,
        ancestors: [],
        ancestorElements: [],
      };
    }

    let current = page.elements;
    let element = null;
    const ancestors = ['Page'];
    const ancestorElements = [];

    for (let i = 1; i < path.length; i++) {
      const idx = path[i];
      if (!current || idx >= current.length) return null;
      element = current[idx];
      if (i < path.length - 1) {
        ancestors.push(element.nodeType);
        ancestorElements.push(element);
        current = element.children;
      }
    }

    return element ? { element, pageIdx, ancestors, ancestorElements } : null;
  }

  function findPathForElement(pageIdx, target) {
    if (!layoutData) return null;
    const page = layoutData.pages[pageIdx];
    if (!page) return null;

    function walk(elements, pathSoFar) {
      for (let i = 0; i < elements.length; i++) {
        const el = elements[i];
        if (el === target) return [...pathSoFar, i];
        if (el.children && el.children.length) {
          const found = walk(el.children, [...pathSoFar, i]);
          if (found) return found;
        }
      }
      return null;
    }

    return walk(page.elements, [pageIdx]);
  }

  function updateTreeSelection(path) {
    // Clear previous selection
    componentTree.querySelectorAll('.tree-node.selected').forEach(n => n.classList.remove('selected'));

    if (!path) return;

    const pathStr = JSON.stringify(path);
    const node = componentTree.querySelector(`.tree-node[data-path='${pathStr}']`);
    if (node) {
      node.classList.add('selected');

      // Expand parent tree nodes to make this visible
      let parent = node.parentElement;
      while (parent && parent !== componentTree) {
        if (parent.classList.contains('tree-children')) {
          parent.classList.add('expanded');
          const arrow = parent.previousElementSibling?.querySelector('.arrow');
          if (arrow && arrow.classList.contains('has-children')) {
            arrow.textContent = '\u25BE';
          }
        }
        parent = parent.parentElement;
      }

      // Scroll tree to show the node
      node.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
    }
  }

  function scrollToElement(element, pageIdx) {
    const wrapper = pagesEl.querySelector(`.page-wrapper[data-page-index="${pageIdx}"]`);
    if (!wrapper) return;

    const wrapperRect = wrapper.getBoundingClientRect();
    const containerRect = containerEl.getBoundingClientRect();
    const elementTop = wrapperRect.top - containerRect.top + containerEl.scrollTop + element.y * currentZoom;

    // Only scroll if element is not visible
    const viewTop = containerEl.scrollTop;
    const viewBottom = viewTop + containerEl.clientHeight;
    if (elementTop < viewTop || elementTop > viewBottom - 50) {
      containerEl.scrollTo({ top: elementTop - 100, behavior: 'smooth' });
    }
  }

  // -- Data Editor -------------------------------------------------
  let dataDebounceTimer = null;

  dataEditor.addEventListener('input', () => {
    if (dataDebounceTimer) clearTimeout(dataDebounceTimer);
    dataDebounceTimer = setTimeout(() => {
      const content = dataEditor.value;
      try {
        const parsed = JSON.parse(content);
        dataEditor.classList.remove('error');
        dataError.classList.remove('visible');
        dataError.textContent = '';
        sendWs({ type: 'updateData', data: parsed });
      } catch (err) {
        dataEditor.classList.add('error');
        dataError.textContent = `Invalid JSON: ${err.message}`;
        dataError.classList.add('visible');
      }
    }, 500);
  });

  dataSaveBtn.addEventListener('click', () => {
    const content = dataEditor.value;
    try {
      JSON.parse(content); // validate
      sendWs({ type: 'saveData', content });
      dataFeedback.textContent = 'Saved!';
      setTimeout(() => { dataFeedback.textContent = ''; }, 2000);
    } catch (err) {
      dataEditor.classList.add('error');
      dataError.textContent = `Invalid JSON: ${err.message}`;
      dataError.classList.add('visible');
    }
  });

  // -- Link Following -----------------------------------------------
  /// Walk the hit element and its ancestors to find the nearest href.
  function findHrefInChain(element, ancestorElements) {
    if (element && element.href) return element.href;
    for (let i = ancestorElements.length - 1; i >= 0; i--) {
      if (ancestorElements[i].href) return ancestorElements[i].href;
    }
    return null;
  }

  /// Search all pages for an element with a matching bookmark title.
  /// Returns { element, pageIdx } or null.
  function findBookmarkTarget(title) {
    if (!layoutData) return null;
    for (let pi = 0; pi < layoutData.pages.length; pi++) {
      const found = findBookmarkInElements(layoutData.pages[pi].elements, pi, title);
      if (found) return found;
    }
    return null;
  }

  function findBookmarkInElements(elements, pageIdx, title) {
    for (const el of elements) {
      if (el.bookmark === title) return { element: el, pageIdx };
      if (el.children && el.children.length) {
        const found = findBookmarkInElements(el.children, pageIdx, title);
        if (found) return found;
      }
    }
    return null;
  }

  function followHref(href) {
    if (href.startsWith('#')) {
      const anchor = href.slice(1);
      const target = findBookmarkTarget(anchor);
      if (target) {
        scrollToElement(target.element, target.pageIdx);
        // Also select the target in the inspector
        const path = findPathForElement(target.pageIdx, target.element);
        if (path) selectByPath(path);
      }
    } else {
      window.open(href, '_blank');
    }
  }

  // -- Cmd/Ctrl key tracking for link hover cursor ------------------
  let lastHoverClientX = 0;
  let lastHoverClientY = 0;
  let cmdHeld = false;

  function getHitLayerUnderPoint(cx, cy) {
    // Use elementFromPoint to find the hit-layer currently under the cursor,
    // avoiding stale references after page re-renders.
    const el = document.elementFromPoint(cx, cy);
    if (el && el.classList.contains('hit-layer')) return el;
    // Could be a child or parent; walk up
    if (el) {
      const parent = el.closest('.hit-layer');
      if (parent) return parent;
    }
    return null;
  }

  function reevaluateLinkCursor(metaHeld) {
    if (!layoutData) return;

    const hitLayer = getHitLayerUnderPoint(lastHoverClientX, lastHoverClientY);
    if (!hitLayer) return;

    const pageIdx = parseInt(hitLayer.dataset.pageIndex, 10);
    const page = layoutData.pages[pageIdx];
    if (!page) return;

    const rect = hitLayer.getBoundingClientRect();
    const px = (lastHoverClientX - rect.left) / currentZoom;
    const py = (lastHoverClientY - rect.top) / currentZoom;

    if (metaHeld) {
      const { element: hit, ancestorElements } = hitTest(page.elements, px, py);
      const href = hit ? findHrefInChain(hit, ancestorElements) : null;
      if (href) {
        hitLayer.style.cursor = 'pointer';
        tooltip.textContent = href.startsWith('#') ? `Go to: ${href.slice(1)}` : href;
        tooltip.style.display = 'block';
        tooltip.style.left = (lastHoverClientX + 12) + 'px';
        tooltip.style.top = (lastHoverClientY + 12) + 'px';
        return;
      }
    }
    hitLayer.style.cursor = '';
    tooltip.style.display = 'none';
  }

  // Track mouse position globally so we always have the latest coords
  document.addEventListener('mousemove', (e) => {
    lastHoverClientX = e.clientX;
    lastHoverClientY = e.clientY;
  });

  document.addEventListener('keydown', (e) => {
    if (e.key === 'Meta' || e.key === 'Control') {
      cmdHeld = true;
      reevaluateLinkCursor(true);
    }
  });

  document.addEventListener('keyup', (e) => {
    if (e.key === 'Meta' || e.key === 'Control') {
      cmdHeld = false;
      reevaluateLinkCursor(false);
    }
  });

  // -- Hit Testing -------------------------------------------------
  function hitTest(elements, px, py) {
    let best = null;
    let bestAncestorNames = [];
    let bestAncestorElements = [];
    const nameStack = [];
    const elemStack = [];
    function walk(els) {
      for (const el of els) {
        const inside = px >= el.x && px <= el.x + el.width && py >= el.y && py <= el.y + el.height;
        if (inside) {
          best = el;
          bestAncestorNames = nameStack.slice();
          bestAncestorElements = elemStack.slice();
        }
        if (el.children && el.children.length) {
          nameStack.push(el.nodeType);
          elemStack.push(el);
          walk(el.children);
          nameStack.pop();
          elemStack.pop();
        }
      }
    }
    walk(elements);
    return { element: best, ancestors: bestAncestorNames, ancestorElements: bestAncestorElements };
  }

  // -- Render PDF pages --------------------------------------------
  let currentPdfDoc = null;

  async function renderPdfPages() {
    const resp = await fetch('/pdf');
    if (!resp.ok) return;
    const buffer = await resp.arrayBuffer();

    currentPdfDoc = await pdfjsLib.getDocument({ data: buffer }).promise;
    await reRenderPages();
  }

  async function reRenderPages() {
    if (!currentPdfDoc) return;
    const pdf = currentPdfDoc;
    const dpr = window.devicePixelRatio || 1;

    const scrollTop = containerEl.scrollTop;

    pagesEl.innerHTML = '';

    pageBadge.style.display = 'inline-flex';
    pageCountEl.textContent = String(pdf.numPages);

    for (let i = 1; i <= pdf.numPages; i++) {
      const page = await pdf.getPage(i);
      const viewport = page.getViewport({ scale: currentZoom });

      const wrapper = document.createElement('div');
      wrapper.className = 'page-wrapper';
      wrapper.dataset.pageIndex = String(i - 1);

      const pdfCanvas = document.createElement('canvas');
      pdfCanvas.className = 'pdf-canvas';
      pdfCanvas.width = viewport.width * dpr;
      pdfCanvas.height = viewport.height * dpr;
      pdfCanvas.style.width = viewport.width + 'px';
      pdfCanvas.style.height = viewport.height + 'px';

      const overlayCanvas = document.createElement('canvas');
      overlayCanvas.className = 'overlay-canvas';
      overlayCanvas.width = viewport.width * dpr;
      overlayCanvas.height = viewport.height * dpr;
      overlayCanvas.style.width = viewport.width + 'px';
      overlayCanvas.style.height = viewport.height + 'px';

      const hitLayer = document.createElement('div');
      hitLayer.className = 'hit-layer';
      hitLayer.dataset.pageIndex = String(i - 1);

      wrapper.appendChild(pdfCanvas);
      wrapper.appendChild(overlayCanvas);
      wrapper.appendChild(hitLayer);
      pagesEl.appendChild(wrapper);

      const ctx = pdfCanvas.getContext('2d');
      const scaledViewport = page.getViewport({ scale: currentZoom * dpr });
      await page.render({ canvasContext: ctx, viewport: scaledViewport }).promise;

      hitLayer.addEventListener('click', onCanvasClick);
      hitLayer.addEventListener('mousemove', onCanvasHover);
      hitLayer.addEventListener('mouseleave', (e) => {
        e.currentTarget.style.cursor = '';
        tooltip.style.display = 'none';
        drawOverlays();
      });
    }

    containerEl.scrollTop = scrollTop;
    drawOverlays();
  }

  function getPageCoords(e) {
    const hitLayer = e.currentTarget;
    const pageIdx = parseInt(hitLayer.dataset.pageIndex, 10);
    const rect = hitLayer.getBoundingClientRect();
    const px = (e.clientX - rect.left) / currentZoom;
    const py = (e.clientY - rect.top) / currentZoom;
    return { pageIdx, px, py };
  }

  function onCanvasClick(e) {
    if (!layoutData) return;
    const { pageIdx, px, py } = getPageCoords(e);
    const page = layoutData.pages[pageIdx];
    if (!page) return;

    const { element: hit, ancestors, ancestorElements } = hitTest(page.elements, px, py);
    if (hit) {
      // Cmd/Ctrl+click follows links
      if ((e.metaKey || e.ctrlKey) && hit) {
        const href = findHrefInChain(hit, ancestorElements);
        if (href) {
          followHref(href);
          return;
        }
      }

      selectedAncestors = ancestors;
      selectedAncestorElements = ancestorElements;
      openInspector(hit, pageIdx);

      // Sync tree selection
      const path = findPathForElement(pageIdx, hit);
      if (path) {
        selectedPath = path;
        updateTreeSelection(path);
      }
    } else {
      closeInspector();
    }
  }

  function onCanvasHover(e) {
    const hitLayer = e.currentTarget;

    // Cmd/Ctrl held: show pointer cursor over linked elements
    if ((e.metaKey || e.ctrlKey) && layoutData) {
      const { pageIdx, px, py } = getPageCoords(e);
      const page = layoutData.pages[pageIdx];
      if (page) {
        const { element: hit, ancestorElements } = hitTest(page.elements, px, py);
        const href = hit ? findHrefInChain(hit, ancestorElements) : null;
        if (href) {
          hitLayer.style.cursor = 'pointer';
          tooltip.textContent = href.startsWith('#') ? `Go to: ${href.slice(1)}` : href;
          tooltip.style.display = 'block';
          tooltip.style.left = (e.clientX + 12) + 'px';
          tooltip.style.top = (e.clientY + 12) + 'px';
          drawOverlays(hit, pageIdx);
          return;
        }
      }
    }

    hitLayer.style.cursor = '';

    if (currentMode !== 'layout' || !layoutData) {
      tooltip.style.display = 'none';
      return;
    }
    const { pageIdx, px, py } = getPageCoords(e);
    const page = layoutData.pages[pageIdx];
    if (!page) return;

    const { element: hit } = hitTest(page.elements, px, py);
    if (hit) {
      tooltip.textContent = `${hit.nodeType} ${fmt(hit.width)}\u00d7${fmt(hit.height)}`;
      tooltip.style.display = 'block';
      tooltip.style.left = (e.clientX + 12) + 'px';
      tooltip.style.top = (e.clientY + 12) + 'px';

      drawOverlays(hit, pageIdx);
    } else {
      tooltip.style.display = 'none';
      drawOverlays();
    }
  }

  // -- Fetch Layout ------------------------------------------------
  async function fetchLayout() {
    try {
      const resp = await fetch('/layout');
      if (resp.ok) {
        layoutData = await resp.json();
        renderComponentTree();
      }
    } catch { /* ignore */ }
  }

  // -- Draw Debug Overlays -----------------------------------------
  function drawOverlays(hoverElement, hoverPageIdx) {
    const wrappers = pagesEl.querySelectorAll('.page-wrapper');
    wrappers.forEach((wrapper) => {
      const overlay = wrapper.querySelector('.overlay-canvas');
      const pageIdx = parseInt(wrapper.dataset.pageIndex, 10);
      const dpr = window.devicePixelRatio || 1;
      const ctx = overlay.getContext('2d');
      ctx.clearRect(0, 0, overlay.width, overlay.height);
      ctx.save();
      ctx.scale(dpr, dpr);

      if (!layoutData || !layoutData.pages[pageIdx]) { ctx.restore(); return; }
      const page = layoutData.pages[pageIdx];

      if (currentMode === 'layout') {
        drawLayoutOverlay(ctx, page.elements);
      }

      if (currentMode === 'margins') {
        drawMarginsOverlay(ctx, page);
      }

      if (currentMode === 'breaks') {
        drawBreaksOverlay(ctx, page, pageIdx);
      }

      // Hover highlight
      if (hoverElement && hoverPageIdx === pageIdx) {
        const color = NODE_TYPE_COLORS[hoverElement.nodeType] || '#a1a1aa';
        ctx.fillStyle = hexToRgba(color, 0.1);
        ctx.fillRect(
          hoverElement.x * currentZoom,
          hoverElement.y * currentZoom,
          hoverElement.width * currentZoom,
          hoverElement.height * currentZoom
        );
        ctx.strokeStyle = hexToRgba(color, 0.6);
        ctx.lineWidth = 1;
        ctx.strokeRect(
          hoverElement.x * currentZoom,
          hoverElement.y * currentZoom,
          hoverElement.width * currentZoom,
          hoverElement.height * currentZoom
        );
      }

      // Selected element highlight
      if (selectedElement && selectedPageIdx === pageIdx) {
        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 2;
        ctx.setLineDash([]);
        ctx.strokeRect(
          selectedElement.x * currentZoom,
          selectedElement.y * currentZoom,
          selectedElement.width * currentZoom,
          selectedElement.height * currentZoom
        );

        if (inspectorOpen && selectedElement.style) {
          const s = selectedElement.style;
          const m = s.margin;
          const ex = selectedElement.x * currentZoom;
          const ey = selectedElement.y * currentZoom;
          const ew = selectedElement.width * currentZoom;
          const eh = selectedElement.height * currentZoom;

          ctx.fillStyle = 'rgba(251, 146, 60, 0.1)';
          if (m.top > 0) ctx.fillRect(ex, ey - m.top * currentZoom, ew, m.top * currentZoom);
          if (m.bottom > 0) ctx.fillRect(ex, ey + eh, ew, m.bottom * currentZoom);
          if (m.left > 0) ctx.fillRect(ex - m.left * currentZoom, ey, m.left * currentZoom, eh);
          if (m.right > 0) ctx.fillRect(ex + ew, ey, m.right * currentZoom, eh);

          const p = s.padding;
          const bw = s.borderWidth;
          ctx.fillStyle = 'rgba(74, 222, 128, 0.1)';
          const innerX = ex + bw.left * currentZoom;
          const innerY = ey + bw.top * currentZoom;
          const innerW = ew - (bw.left + bw.right) * currentZoom;
          const innerH = eh - (bw.top + bw.bottom) * currentZoom;
          if (p.top > 0) ctx.fillRect(innerX, innerY, innerW, p.top * currentZoom);
          if (p.bottom > 0) ctx.fillRect(innerX, innerY + innerH - p.bottom * currentZoom, innerW, p.bottom * currentZoom);
          if (p.left > 0) ctx.fillRect(innerX, innerY + p.top * currentZoom, p.left * currentZoom, innerH - (p.top + p.bottom) * currentZoom);
          if (p.right > 0) ctx.fillRect(innerX + innerW - p.right * currentZoom, innerY + p.top * currentZoom, p.right * currentZoom, innerH - (p.top + p.bottom) * currentZoom);
        }
      }

      ctx.restore();
    });
  }

  function drawLayoutOverlay(ctx, elements) {
    for (const el of elements) {
      const color = NODE_TYPE_COLORS[el.nodeType] || '#6b7280';
      ctx.strokeStyle = hexToRgba(color, 0.5);
      ctx.lineWidth = 1;
      ctx.strokeRect(
        el.x * currentZoom,
        el.y * currentZoom,
        el.width * currentZoom,
        el.height * currentZoom
      );
      if (el.children && el.children.length) {
        drawLayoutOverlay(ctx, el.children);
      }
    }
  }

  function drawMarginsOverlay(ctx, page) {
    ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)';
    ctx.lineWidth = 1;
    ctx.setLineDash([6, 4]);
    ctx.strokeRect(
      page.contentX * currentZoom,
      page.contentY * currentZoom,
      page.contentWidth * currentZoom,
      page.contentHeight * currentZoom
    );
    ctx.setLineDash([]);

    ctx.fillStyle = 'rgba(59, 130, 246, 0.05)';
    const pw = page.width * currentZoom;
    const ph = page.height * currentZoom;
    const cx = page.contentX * currentZoom;
    const cy = page.contentY * currentZoom;
    const cw = page.contentWidth * currentZoom;
    const ch = page.contentHeight * currentZoom;
    ctx.fillRect(0, 0, pw, cy);
    ctx.fillRect(0, cy + ch, pw, ph - cy - ch);
    ctx.fillRect(0, cy, cx, ch);
    ctx.fillRect(cx + cw, cy, pw - cx - cw, ch);

    drawElementSpacing(ctx, page.elements);
  }

  function drawElementSpacing(ctx, elements) {
    for (const el of elements) {
      if (el.style) {
        const m = el.style.margin;
        const p = el.style.padding;

        if (m.top > 0 || m.bottom > 0 || m.left > 0 || m.right > 0) {
          ctx.fillStyle = 'rgba(251, 146, 60, 0.08)';
          const ex = el.x * currentZoom;
          const ey = el.y * currentZoom;
          const ew = el.width * currentZoom;
          const eh = el.height * currentZoom;
          if (m.top > 0) ctx.fillRect(ex, ey - m.top * currentZoom, ew, m.top * currentZoom);
          if (m.bottom > 0) ctx.fillRect(ex, ey + eh, ew, m.bottom * currentZoom);
          if (m.left > 0) ctx.fillRect(ex - m.left * currentZoom, ey, m.left * currentZoom, eh);
          if (m.right > 0) ctx.fillRect(ex + ew, ey, m.right * currentZoom, eh);
        }

        if (p.top > 0 || p.bottom > 0 || p.left > 0 || p.right > 0) {
          ctx.fillStyle = 'rgba(74, 222, 128, 0.08)';
          const bw = el.style.borderWidth;
          const ix = (el.x + bw.left) * currentZoom;
          const iy = (el.y + bw.top) * currentZoom;
          const iw = (el.width - bw.left - bw.right) * currentZoom;
          const ih = (el.height - bw.top - bw.bottom) * currentZoom;
          if (p.top > 0) ctx.fillRect(ix, iy, iw, p.top * currentZoom);
          if (p.bottom > 0) ctx.fillRect(ix, iy + ih - p.bottom * currentZoom, iw, p.bottom * currentZoom);
          if (p.left > 0) ctx.fillRect(ix, iy + p.top * currentZoom, p.left * currentZoom, ih - (p.top + p.bottom) * currentZoom);
          if (p.right > 0) ctx.fillRect(ix + iw - p.right * currentZoom, iy + p.top * currentZoom, p.right * currentZoom, ih - (p.top + p.bottom) * currentZoom);
        }
      }
      if (el.children && el.children.length) {
        drawElementSpacing(ctx, el.children);
      }
    }
  }

  function drawBreaksOverlay(ctx, page, pageIdx) {
    if (pageIdx > 0) {
      const y = page.contentY * currentZoom;
      ctx.strokeStyle = '#ef4444';
      ctx.lineWidth = 1.5;
      ctx.setLineDash([8, 4]);
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(page.width * currentZoom, y);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.fillStyle = '#ef4444';
      ctx.font = '10px ' + getComputedStyle(document.body).fontFamily;
      ctx.fillText(`break at y=${fmt(page.contentY)}`, 8 * currentZoom, y - 4);
    }

    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.font = `bold ${12 * currentZoom}px ${getComputedStyle(document.body).fontFamily}`;
    ctx.fillText(
      `Page ${pageIdx + 1}`,
      page.contentX * currentZoom + 4,
      (page.contentY + 14) * currentZoom
    );
  }

  function hexToRgba(hex, alpha) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
  }

  // -- WebSocket helpers -------------------------------------------
  function sendWs(msg) {
    if (wsRef && wsRef.readyState === WebSocket.OPEN) {
      wsRef.send(JSON.stringify(msg));
    }
  }

  // -- Full reload cycle -------------------------------------------
  async function reload() {
    errorEl.style.display = 'none';
    await renderPdfPages();
    await fetchLayout();
    drawOverlays();
  }

  // -- Keyboard shortcuts ------------------------------------------
  document.addEventListener('keydown', (e) => {
    // Don't intercept when typing in data editor
    if (e.target === dataEditor) return;

    if (!e.metaKey && !e.ctrlKey && !e.altKey) {
      if (e.key === '1') { e.preventDefault(); setMode('preview'); }
      if (e.key === '2') { e.preventDefault(); setMode('layout'); }
      if (e.key === '3') { e.preventDefault(); setMode('margins'); }
      if (e.key === '4') { e.preventDefault(); setMode('breaks'); }
      if (e.key === 'Escape') { e.preventDefault(); closeInspector(); }
      if (e.key === 't' || e.key === 'T') { e.preventDefault(); setSidebarOpen(!sidebarOpen); }
      if (e.key === 'Enter' && selectedElement) {
        let enterSl = selectedElement.sourceLocation;
        if (!enterSl) {
          for (let i = selectedAncestorElements.length - 1; i >= 0; i--) {
            if (selectedAncestorElements[i].sourceLocation) { enterSl = selectedAncestorElements[i].sourceLocation; break; }
          }
        }
        if (enterSl) { e.preventDefault(); openInEditor(enterSl); }
      }
    }

    if (e.metaKey || e.ctrlKey) {
      if (e.key === '=' || e.key === '+') { e.preventDefault(); zoomIn(); }
      if (e.key === '-') { e.preventDefault(); zoomOut(); }
      if (e.key === '0') { e.preventDefault(); zoomToFit(); }
    }
  });

  containerEl.addEventListener('wheel', (e) => {
    if (e.metaKey || e.ctrlKey) {
      e.preventDefault();
      if (e.deltaY < 0) zoomIn();
      else zoomOut();
    }
  }, { passive: false });

  // -- WebSocket ---------------------------------------------------
  function connectWs() {
    const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
    const ws = new WebSocket(`${protocol}//${location.host}`);
    wsRef = ws;

    ws.addEventListener('open', () => {
      statusDot.className = 'status-dot connected';
      // Re-send page size override on reconnect
      resendPageSizeOverride();
    });

    ws.addEventListener('close', () => {
      statusDot.className = 'status-dot disconnected';
      wsRef = null;
      setTimeout(connectWs, 1000);
    });

    ws.addEventListener('message', async (event) => {
      const msg = JSON.parse(event.data);

      if (msg.type === 'init') {
        hasDataFile = msg.hasData;
        dataTabBtn.style.display = hasDataFile ? '' : 'none';
        if (hasDataFile && msg.dataContent) {
          dataEditor.value = msg.dataContent;
        }
        // Apply server-side page size override if reconnecting
        if (msg.pageSizeOverride) {
          // Server already has override; UI should already match via localStorage
        }
      }

      if (msg.type === 'reload') {
        if (msg.renderTime) {
          renderTimeEl.textContent = msg.renderTime + 'ms';
          renderBadge.style.display = 'inline-flex';
        }
        await reload();
        // Auto-zoom to fit after page size changes
        setTimeout(zoomToFit, 300);
      }

      if (msg.type === 'error') {
        errorEl.querySelector('.error-dismiss').nextSibling?.remove();
        errorEl.appendChild(document.createTextNode(msg.message));
        errorEl.style.display = 'block';
      }

      if (msg.type === 'dataUpdate') {
        // File changed on disk; update editor if not focused
        if (document.activeElement !== dataEditor) {
          dataEditor.value = msg.content;
          dataEditor.classList.remove('error');
          dataError.classList.remove('visible');
          dataError.textContent = '';
        }
      }
    });
  }

  // -- Init --------------------------------------------------------
  connectWs();
  reload().then(() => {
    setTimeout(zoomToFit, 100);
  }).catch(() => {});
</script>
</body>
</html>
