<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Forme Preview</title>
<style>
  :root {
    --bg: #0a0a0b;
    --surface: #18181b;
    --surface-2: #1f1f23;
    --border: #27272a;
    --border-hover: #3f3f46;
    --text: #fafafa;
    --text-muted: #a1a1aa;
    --text-dim: #71717a;
    --accent: #3b82f6;
    --accent-hover: #2563eb;
    --inspector-width: 320px;
    --toolbar-height: 44px;
    --font-mono: 'SF Mono', 'Fira Code', 'Cascadia Code', 'JetBrains Mono', monospace;
    --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: var(--font-sans);
    overflow: hidden;
    height: 100vh;
  }

  /* ── Toolbar ─────────────────────────────────── */
  #toolbar {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 200;
    height: var(--toolbar-height);
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    padding: 0 12px;
    gap: 12px;
    font-size: 13px;
    -webkit-app-region: drag;
  }

  .toolbar-group {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-shrink: 0;
  }

  .wordmark {
    font-weight: 700;
    font-size: 14px;
    letter-spacing: -0.02em;
    color: var(--text);
    user-select: none;
  }

  .wordmark span { color: var(--text-dim); font-weight: 400; }

  .toolbar-separator {
    width: 1px;
    height: 20px;
    background: var(--border);
    flex-shrink: 0;
  }

  /* ── Segmented Control ────────────────────────── */
  .segmented-control {
    display: flex;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 2px;
    gap: 1px;
    -webkit-app-region: no-drag;
  }

  .segmented-control button {
    background: transparent;
    color: var(--text-muted);
    border: none;
    border-radius: 4px;
    padding: 4px 10px;
    font-size: 11px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s ease;
    white-space: nowrap;
    position: relative;
  }

  .segmented-control button:hover {
    color: var(--text);
    background: var(--surface-2);
  }

  .segmented-control button.active {
    background: var(--surface-2);
    color: var(--text);
    box-shadow: 0 1px 2px rgba(0,0,0,0.3);
  }

  .segmented-control button .shortcut {
    display: inline-block;
    margin-left: 4px;
    font-size: 9px;
    color: var(--text-dim);
    opacity: 0.6;
  }

  /* ── Toolbar meta ──────────────────────────────── */
  .toolbar-spacer { flex: 1; }

  .badge {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 11px;
    font-family: var(--font-mono);
    background: var(--bg);
    border: 1px solid var(--border);
    color: var(--text-dim);
  }

  .badge.render-time { color: #4ade80; }
  .badge.page-count { color: var(--text-muted); }

  /* ── Zoom controls ─────────────────────────────── */
  .zoom-controls {
    display: flex;
    align-items: center;
    gap: 2px;
    -webkit-app-region: no-drag;
  }

  .zoom-controls button {
    background: transparent;
    color: var(--text-muted);
    border: 1px solid var(--border);
    width: 28px;
    height: 28px;
    border-radius: 4px;
    font-size: 14px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s;
  }

  .zoom-controls button:hover {
    background: var(--surface-2);
    color: var(--text);
    border-color: var(--border-hover);
  }

  .zoom-level {
    min-width: 44px;
    text-align: center;
    font-size: 11px;
    font-family: var(--font-mono);
    color: var(--text-muted);
    user-select: none;
  }

  /* ── Status dot ────────────────────────────────── */
  .status-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--text-dim);
    flex-shrink: 0;
  }
  .status-dot.connected { background: #4ade80; }
  .status-dot.disconnected { background: #ef4444; }

  /* ── Canvas Container ──────────────────────────── */
  #canvas-container {
    position: fixed;
    top: var(--toolbar-height);
    left: 0;
    right: 0;
    bottom: 0;
    overflow: auto;
    transition: margin-right 0.2s ease-out;
  }

  #canvas-container.inspector-open {
    margin-right: var(--inspector-width);
  }

  #pages {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    padding: 32px 20px 60px;
    min-height: 100%;
  }

  .page-wrapper {
    position: relative;
    box-shadow: 0 2px 16px rgba(0,0,0,0.5), 0 0 0 1px rgba(255,255,255,0.03);
    border-radius: 2px;
    cursor: default;
  }

  .page-wrapper canvas.pdf-canvas {
    display: block;
    background: #fff;
    border-radius: 2px;
  }

  .page-wrapper canvas.overlay-canvas {
    position: absolute;
    top: 0;
    left: 0;
    pointer-events: none;
    border-radius: 2px;
  }

  .page-wrapper .hit-layer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    cursor: default;
  }

  /* ── Hover tooltip ─────────────────────────────── */
  #hover-tooltip {
    position: fixed;
    z-index: 300;
    pointer-events: none;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 3px 8px;
    font-size: 11px;
    font-family: var(--font-mono);
    color: var(--text-muted);
    white-space: nowrap;
    display: none;
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
  }

  /* ── Inspector Panel ───────────────────────────── */
  #inspector {
    position: fixed;
    top: var(--toolbar-height);
    right: 0;
    bottom: 0;
    width: var(--inspector-width);
    background: var(--surface);
    border-left: 1px solid var(--border);
    z-index: 150;
    overflow-y: auto;
    transform: translateX(100%);
    transition: transform 0.2s ease-out;
    font-size: 12px;
  }

  #inspector.open {
    transform: translateX(0);
  }

  .inspector-header {
    padding: 12px 16px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: space-between;
    position: sticky;
    top: 0;
    background: var(--surface);
    z-index: 1;
  }

  .inspector-header .node-label {
    font-weight: 600;
    font-size: 13px;
  }

  .inspector-header .node-dims {
    font-family: var(--font-mono);
    font-size: 11px;
    color: var(--text-dim);
  }

  .inspector-header .close-btn {
    background: transparent;
    border: none;
    color: var(--text-dim);
    cursor: pointer;
    font-size: 16px;
    padding: 2px 6px;
    border-radius: 4px;
    line-height: 1;
  }
  .inspector-header .close-btn:hover {
    background: var(--surface-2);
    color: var(--text);
  }

  /* ── Box Model Diagram ─────────────────────────── */
  .box-model {
    padding: 16px;
    border-bottom: 1px solid var(--border);
  }

  .box-model-title {
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--text-dim);
    margin-bottom: 12px;
  }

  .box-model-diagram {
    position: relative;
    width: 100%;
    aspect-ratio: 1.6;
    font-family: var(--font-mono);
    font-size: 10px;
    user-select: none;
  }

  .box-margin {
    position: absolute;
    inset: 0;
    background: rgba(251, 146, 60, 0.12);
    border: 1px dashed rgba(251, 146, 60, 0.4);
    border-radius: 4px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  .box-border-area {
    position: absolute;
    inset: 18%;
    background: rgba(96, 165, 250, 0.12);
    border: 1px solid rgba(96, 165, 250, 0.4);
    border-radius: 3px;
  }

  .box-padding {
    position: absolute;
    inset: 30%;
    background: rgba(74, 222, 128, 0.12);
    border: 1px dashed rgba(74, 222, 128, 0.4);
    border-radius: 2px;
  }

  .box-content {
    position: absolute;
    inset: 42%;
    background: rgba(96, 165, 250, 0.2);
    border-radius: 2px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-muted);
    font-size: 9px;
  }

  .box-label {
    position: absolute;
    color: var(--text-dim);
    font-size: 9px;
  }
  .box-label.top { top: 2px; left: 50%; transform: translateX(-50%); }
  .box-label.bottom { bottom: 2px; left: 50%; transform: translateX(-50%); }
  .box-label.left { left: 4px; top: 50%; transform: translateY(-50%); }
  .box-label.right { right: 4px; top: 50%; transform: translateY(-50%); }
  .box-label.margin-label { color: #fb923c; }
  .box-label.border-label { color: #60a5fa; }
  .box-label.padding-label { color: #4ade80; }

  /* ── Computed Styles ───────────────────────────── */
  .style-section {
    padding: 12px 16px;
    border-bottom: 1px solid var(--border);
  }

  .style-section-title {
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--text-dim);
    margin-bottom: 8px;
  }

  .style-row {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    padding: 2px 0;
    font-size: 11px;
  }

  .style-row .prop {
    color: var(--text-muted);
  }

  .style-row .val {
    font-family: var(--font-mono);
    color: var(--text);
    text-align: right;
  }

  .color-swatch {
    display: inline-block;
    width: 10px;
    height: 10px;
    border-radius: 2px;
    border: 1px solid var(--border);
    vertical-align: middle;
    margin-right: 4px;
  }

  /* ── Error Overlay ─────────────────────────────── */
  #error-overlay {
    display: none;
    position: fixed;
    top: var(--toolbar-height);
    left: 0;
    right: 0;
    z-index: 180;
    background: #450a0a;
    border-bottom: 1px solid #7f1d1d;
    color: #fca5a5;
    padding: 12px 20px;
    font-family: var(--font-mono);
    font-size: 12px;
    white-space: pre-wrap;
    word-break: break-word;
    max-height: 200px;
    overflow-y: auto;
  }

  #error-overlay .error-dismiss {
    position: absolute;
    top: 8px;
    right: 12px;
    background: transparent;
    border: none;
    color: #fca5a5;
    cursor: pointer;
    font-size: 14px;
    opacity: 0.6;
  }
  #error-overlay .error-dismiss:hover { opacity: 1; }

  /* ── Crossfade animation ───────────────────────── */
  .page-wrapper.fading {
    opacity: 0;
    transition: opacity 0.15s ease;
  }
  .page-wrapper.visible {
    opacity: 1;
    transition: opacity 0.15s ease;
  }
</style>
</head>
<body>

<div id="toolbar">
  <div class="toolbar-group">
    <div class="status-dot" id="status-dot"></div>
    <div class="wordmark">forme <span>preview</span></div>
  </div>

  <div class="toolbar-separator"></div>

  <div class="segmented-control" id="mode-control">
    <button data-mode="preview" class="active">Preview <span class="shortcut">1</span></button>
    <button data-mode="layout">Layout <span class="shortcut">2</span></button>
    <button data-mode="margins">Margins <span class="shortcut">3</span></button>
    <button data-mode="breaks">Breaks <span class="shortcut">4</span></button>
  </div>

  <div class="toolbar-spacer"></div>

  <div class="badge render-time" id="render-badge" style="display:none">
    <span id="render-time">0ms</span>
  </div>
  <div class="badge page-count" id="page-badge" style="display:none">
    <span id="page-count">0</span> pages
  </div>

  <div class="toolbar-separator"></div>

  <div class="zoom-controls">
    <button id="zoom-out" title="Zoom out (Cmd -)">&#x2212;</button>
    <span class="zoom-level" id="zoom-level">100%</span>
    <button id="zoom-in" title="Zoom in (Cmd +)">+</button>
    <button id="zoom-fit" title="Fit to window (Cmd 0)" style="font-size:11px; width:auto; padding: 0 8px;">Fit</button>
  </div>
</div>

<div id="error-overlay">
  <button class="error-dismiss" id="error-dismiss">&times;</button>
</div>

<div id="canvas-container">
  <div id="pages"></div>
</div>

<div id="hover-tooltip"></div>

<div id="inspector">
  <div class="inspector-header">
    <div>
      <div class="node-label" id="inspector-label">View</div>
      <div class="node-dims" id="inspector-dims">0 x 0 at (0, 0)</div>
    </div>
    <button class="close-btn" id="inspector-close">&times;</button>
  </div>

  <div class="box-model">
    <div class="box-model-title">Box Model</div>
    <div class="box-model-diagram" id="box-model-diagram">
      <div class="box-margin">
        <span class="box-label top margin-label" id="bm-margin-top">0</span>
        <span class="box-label bottom margin-label" id="bm-margin-bottom">0</span>
        <span class="box-label left margin-label" id="bm-margin-left">0</span>
        <span class="box-label right margin-label" id="bm-margin-right">0</span>
      </div>
      <div class="box-border-area">
        <span class="box-label top border-label" id="bm-border-top">0</span>
        <span class="box-label bottom border-label" id="bm-border-bottom">0</span>
        <span class="box-label left border-label" id="bm-border-left">0</span>
        <span class="box-label right border-label" id="bm-border-right">0</span>
      </div>
      <div class="box-padding">
        <span class="box-label top padding-label" id="bm-padding-top">0</span>
        <span class="box-label bottom padding-label" id="bm-padding-bottom">0</span>
        <span class="box-label left padding-label" id="bm-padding-left">0</span>
        <span class="box-label right padding-label" id="bm-padding-right">0</span>
      </div>
      <div class="box-content" id="bm-content">0 x 0</div>
    </div>
  </div>

  <div id="inspector-styles"></div>
</div>

<script type="module">
  // ── PDF.js Setup ──────────────────────────────────────────────
  const PDFJS_CDN = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.9.155/pdf.min.mjs';
  const PDFJS_WORKER_CDN = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.9.155/pdf.worker.min.mjs';

  const pdfjsLib = await import(PDFJS_CDN);
  pdfjsLib.GlobalWorkerOptions.workerSrc = PDFJS_WORKER_CDN;

  // ── State ─────────────────────────────────────────────────────
  const ZOOM_LEVELS = [0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 2.0];
  let currentZoomIndex = 3; // 100%
  let currentZoom = 1.0;
  let currentMode = 'preview'; // preview | layout | margins | breaks
  let layoutData = null;
  let selectedElement = null;
  let selectedPageIdx = -1;
  let inspectorOpen = false;

  // ── DOM refs ──────────────────────────────────────────────────
  const pagesEl = document.getElementById('pages');
  const containerEl = document.getElementById('canvas-container');
  const errorEl = document.getElementById('error-overlay');
  const renderTimeEl = document.getElementById('render-time');
  const renderBadge = document.getElementById('render-badge');
  const pageCountEl = document.getElementById('page-count');
  const pageBadge = document.getElementById('page-badge');
  const statusDot = document.getElementById('status-dot');
  const zoomLevelEl = document.getElementById('zoom-level');
  const modeControl = document.getElementById('mode-control');
  const inspectorEl = document.getElementById('inspector');
  const inspectorLabel = document.getElementById('inspector-label');
  const inspectorDims = document.getElementById('inspector-dims');
  const inspectorStyles = document.getElementById('inspector-styles');
  const tooltip = document.getElementById('hover-tooltip');

  // ── Mode Toggle ──────────────────────────────────────────────
  function setMode(mode) {
    currentMode = mode;
    modeControl.querySelectorAll('button').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.mode === mode);
    });
    drawOverlays();
  }

  modeControl.addEventListener('click', (e) => {
    const btn = e.target.closest('button');
    if (btn && btn.dataset.mode) setMode(btn.dataset.mode);
  });

  // ── Zoom ──────────────────────────────────────────────────────
  function setZoom(level) {
    currentZoom = level;
    // Find closest zoom index
    let closest = 0;
    let minDist = Infinity;
    ZOOM_LEVELS.forEach((z, i) => {
      const d = Math.abs(z - level);
      if (d < minDist) { minDist = d; closest = i; }
    });
    currentZoomIndex = closest;
    zoomLevelEl.textContent = Math.round(currentZoom * 100) + '%';
  }

  function zoomIn() {
    if (currentZoomIndex < ZOOM_LEVELS.length - 1) {
      currentZoomIndex++;
      setZoom(ZOOM_LEVELS[currentZoomIndex]);
      reRenderPages();
    }
  }

  function zoomOut() {
    if (currentZoomIndex > 0) {
      currentZoomIndex--;
      setZoom(ZOOM_LEVELS[currentZoomIndex]);
      reRenderPages();
    }
  }

  function zoomToFit() {
    if (!layoutData || !layoutData.pages.length) return;
    const page = layoutData.pages[0];
    const availW = containerEl.clientWidth - 80; // padding
    const availH = containerEl.clientHeight - 100;
    const fitW = availW / page.width;
    const fitH = availH / page.height;
    const fit = Math.min(fitW, fitH, 2.0);
    // Snap to nearest zoom level or use exact
    setZoom(Math.round(fit * 100) / 100);
    reRenderPages();
  }

  document.getElementById('zoom-in').addEventListener('click', zoomIn);
  document.getElementById('zoom-out').addEventListener('click', zoomOut);
  document.getElementById('zoom-fit').addEventListener('click', zoomToFit);

  // ── Inspector ─────────────────────────────────────────────────
  function openInspector(element, pageIdx) {
    selectedElement = element;
    selectedPageIdx = pageIdx;
    inspectorOpen = true;
    inspectorEl.classList.add('open');
    containerEl.classList.add('inspector-open');
    updateInspector();
    drawOverlays();
  }

  function closeInspector() {
    selectedElement = null;
    selectedPageIdx = -1;
    inspectorOpen = false;
    inspectorEl.classList.remove('open');
    containerEl.classList.remove('inspector-open');
    drawOverlays();
  }

  document.getElementById('inspector-close').addEventListener('click', closeInspector);
  document.getElementById('error-dismiss').addEventListener('click', () => {
    errorEl.style.display = 'none';
  });

  function updateInspector() {
    if (!selectedElement) return;
    const el = selectedElement;
    const s = el.style;

    // Header
    const nodeTypeColors = {
      View: '#3b82f6', Text: '#eab308', Image: '#a855f7',
      Table: '#22c55e', TableRow: '#22c55e', TableCell: '#22c55e',
      FixedHeader: '#ef4444', FixedFooter: '#ef4444',
    };
    const color = nodeTypeColors[el.nodeType] || '#a1a1aa';
    inspectorLabel.innerHTML = `<span style="color:${color}">${el.nodeType}</span>`;
    inspectorDims.textContent = `${fmt(el.width)} \u00d7 ${fmt(el.height)} at (${fmt(el.x)}, ${fmt(el.y)})`;

    // Box model
    setText('bm-margin-top', fmt(s.margin.top));
    setText('bm-margin-bottom', fmt(s.margin.bottom));
    setText('bm-margin-left', fmt(s.margin.left));
    setText('bm-margin-right', fmt(s.margin.right));
    setText('bm-border-top', fmt(s.borderWidth.top));
    setText('bm-border-bottom', fmt(s.borderWidth.bottom));
    setText('bm-border-left', fmt(s.borderWidth.left));
    setText('bm-border-right', fmt(s.borderWidth.right));
    setText('bm-padding-top', fmt(s.padding.top));
    setText('bm-padding-bottom', fmt(s.padding.bottom));
    setText('bm-padding-left', fmt(s.padding.left));
    setText('bm-padding-right', fmt(s.padding.right));

    const cw = el.width - s.padding.left - s.padding.right - s.borderWidth.left - s.borderWidth.right;
    const ch = el.height - s.padding.top - s.padding.bottom - s.borderWidth.top - s.borderWidth.bottom;
    setText('bm-content', `${fmt(Math.max(0, cw))} \u00d7 ${fmt(Math.max(0, ch))}`);

    // Computed styles
    let html = '';

    // Layout section
    const layoutProps = [];
    if (s.flexDirection !== 'Column') layoutProps.push(['flex-direction', s.flexDirection]);
    if (s.justifyContent !== 'FlexStart') layoutProps.push(['justify-content', s.justifyContent]);
    if (s.alignItems !== 'Stretch') layoutProps.push(['align-items', s.alignItems]);
    if (s.flexWrap !== 'NoWrap') layoutProps.push(['flex-wrap', s.flexWrap]);
    if (s.gap > 0) layoutProps.push(['gap', fmt(s.gap) + 'pt']);
    if (layoutProps.length) {
      html += renderStyleSection('Layout', layoutProps);
    }

    // Spacing section
    const spacingProps = [];
    const marginStr = edgesShorthand(s.margin);
    const paddingStr = edgesShorthand(s.padding);
    const borderStr = edgesShorthand(s.borderWidth);
    if (marginStr !== '0') spacingProps.push(['margin', marginStr]);
    if (paddingStr !== '0') spacingProps.push(['padding', paddingStr]);
    if (borderStr !== '0') spacingProps.push(['border-width', borderStr]);
    if (spacingProps.length) {
      html += renderStyleSection('Spacing', spacingProps);
    }

    // Typography section
    const typoProps = [];
    typoProps.push(['font-family', s.fontFamily]);
    typoProps.push(['font-size', fmt(s.fontSize) + 'pt']);
    if (s.fontWeight !== 400) typoProps.push(['font-weight', String(s.fontWeight)]);
    if (s.fontStyle !== 'Normal') typoProps.push(['font-style', s.fontStyle]);
    if (s.lineHeight !== 1.4) typoProps.push(['line-height', fmt(s.lineHeight)]);
    if (s.textAlign !== 'Left') typoProps.push(['text-align', s.textAlign]);
    html += renderStyleSection('Typography', typoProps);

    // Visual section
    const visualProps = [];
    visualProps.push(['color', colorHtml(s.color)]);
    if (s.backgroundColor) visualProps.push(['background', colorHtml(s.backgroundColor)]);
    if (s.opacity < 1) visualProps.push(['opacity', fmt(s.opacity)]);
    const radiusStr = cornerShorthand(s.borderRadius);
    if (radiusStr !== '0') visualProps.push(['border-radius', radiusStr]);
    html += renderStyleSection('Background & Border', visualProps);

    inspectorStyles.innerHTML = html;
  }

  function renderStyleSection(title, props) {
    let html = `<div class="style-section"><div class="style-section-title">${title}</div>`;
    for (const [prop, val] of props) {
      html += `<div class="style-row"><span class="prop">${prop}</span><span class="val">${val}</span></div>`;
    }
    html += '</div>';
    return html;
  }

  // ── Helpers ───────────────────────────────────────────────────
  function setText(id, text) { document.getElementById(id).textContent = text; }
  function fmt(n) { return Number.isInteger(n) ? String(n) : n.toFixed(1).replace(/\.0$/, ''); }

  function colorToHex(c) {
    if (!c) return 'transparent';
    const r = Math.round(c.r * 255).toString(16).padStart(2, '0');
    const g = Math.round(c.g * 255).toString(16).padStart(2, '0');
    const b = Math.round(c.b * 255).toString(16).padStart(2, '0');
    return `#${r}${g}${b}`;
  }

  function colorHtml(c) {
    const hex = colorToHex(c);
    return `<span class="color-swatch" style="background:${hex}"></span>${hex}`;
  }

  function edgesShorthand(e) {
    const t = fmt(e.top), r = fmt(e.right), b = fmt(e.bottom), l = fmt(e.left);
    if (t === r && r === b && b === l) return t;
    if (t === b && l === r) return `${t} ${r}`;
    return `${t} ${r} ${b} ${l}`;
  }

  function cornerShorthand(c) {
    const tl = fmt(c.top_left), tr = fmt(c.top_right), br = fmt(c.bottom_right), bl = fmt(c.bottom_left);
    if (tl === tr && tr === br && br === bl) return tl;
    return `${tl} ${tr} ${br} ${bl}`;
  }

  // ── Hit Testing ───────────────────────────────────────────────
  function hitTest(elements, px, py) {
    // Walk depth-first, return deepest match
    let best = null;
    function walk(els) {
      for (const el of els) {
        if (px >= el.x && px <= el.x + el.width && py >= el.y && py <= el.y + el.height) {
          best = el;
          if (el.children && el.children.length) {
            walk(el.children);
          }
        }
      }
    }
    walk(elements);
    return best;
  }

  // ── Render PDF pages ──────────────────────────────────────────
  let currentPdfDoc = null;

  async function renderPdfPages() {
    const resp = await fetch('/pdf');
    if (!resp.ok) return;
    const buffer = await resp.arrayBuffer();

    currentPdfDoc = await pdfjsLib.getDocument({ data: buffer }).promise;
    await reRenderPages();
  }

  async function reRenderPages() {
    if (!currentPdfDoc) return;
    const pdf = currentPdfDoc;
    const dpr = window.devicePixelRatio || 1;

    // Preserve scroll position
    const scrollTop = containerEl.scrollTop;

    pagesEl.innerHTML = '';

    pageBadge.style.display = 'inline-flex';
    pageCountEl.textContent = String(pdf.numPages);

    for (let i = 1; i <= pdf.numPages; i++) {
      const page = await pdf.getPage(i);
      const viewport = page.getViewport({ scale: currentZoom });

      const wrapper = document.createElement('div');
      wrapper.className = 'page-wrapper';
      wrapper.dataset.pageIndex = String(i - 1);

      // PDF canvas
      const pdfCanvas = document.createElement('canvas');
      pdfCanvas.className = 'pdf-canvas';
      pdfCanvas.width = viewport.width * dpr;
      pdfCanvas.height = viewport.height * dpr;
      pdfCanvas.style.width = viewport.width + 'px';
      pdfCanvas.style.height = viewport.height + 'px';

      // Overlay canvas
      const overlayCanvas = document.createElement('canvas');
      overlayCanvas.className = 'overlay-canvas';
      overlayCanvas.width = viewport.width * dpr;
      overlayCanvas.height = viewport.height * dpr;
      overlayCanvas.style.width = viewport.width + 'px';
      overlayCanvas.style.height = viewport.height + 'px';

      // Hit-test layer
      const hitLayer = document.createElement('div');
      hitLayer.className = 'hit-layer';
      hitLayer.dataset.pageIndex = String(i - 1);

      wrapper.appendChild(pdfCanvas);
      wrapper.appendChild(overlayCanvas);
      wrapper.appendChild(hitLayer);
      pagesEl.appendChild(wrapper);

      const ctx = pdfCanvas.getContext('2d');
      const scaledViewport = page.getViewport({ scale: currentZoom * dpr });
      await page.render({ canvasContext: ctx, viewport: scaledViewport }).promise;

      // Attach mouse events
      hitLayer.addEventListener('click', onCanvasClick);
      hitLayer.addEventListener('mousemove', onCanvasHover);
      hitLayer.addEventListener('mouseleave', () => {
        tooltip.style.display = 'none';
        drawOverlays();
      });
    }

    // Restore scroll
    containerEl.scrollTop = scrollTop;

    drawOverlays();
  }

  function getPageCoords(e) {
    const hitLayer = e.currentTarget;
    const pageIdx = parseInt(hitLayer.dataset.pageIndex, 10);
    const rect = hitLayer.getBoundingClientRect();
    const px = (e.clientX - rect.left) / currentZoom;
    const py = (e.clientY - rect.top) / currentZoom;
    return { pageIdx, px, py };
  }

  function onCanvasClick(e) {
    if (!layoutData) return;
    const { pageIdx, px, py } = getPageCoords(e);
    const page = layoutData.pages[pageIdx];
    if (!page) return;

    const hit = hitTest(page.elements, px, py);
    if (hit) {
      openInspector(hit, pageIdx);
    } else {
      closeInspector();
    }
  }

  function onCanvasHover(e) {
    if (currentMode !== 'layout' || !layoutData) {
      tooltip.style.display = 'none';
      return;
    }
    const { pageIdx, px, py } = getPageCoords(e);
    const page = layoutData.pages[pageIdx];
    if (!page) return;

    const hit = hitTest(page.elements, px, py);
    if (hit) {
      tooltip.textContent = `${hit.nodeType} ${fmt(hit.width)}\u00d7${fmt(hit.height)}`;
      tooltip.style.display = 'block';
      tooltip.style.left = (e.clientX + 12) + 'px';
      tooltip.style.top = (e.clientY + 12) + 'px';

      // Draw hover highlight
      drawOverlays(hit, pageIdx);
    } else {
      tooltip.style.display = 'none';
      drawOverlays();
    }
  }

  // ── Fetch Layout ──────────────────────────────────────────────
  async function fetchLayout() {
    try {
      const resp = await fetch('/layout');
      if (resp.ok) {
        layoutData = await resp.json();
      }
    } catch { /* ignore */ }
  }

  // ── Draw Debug Overlays ───────────────────────────────────────
  const NODE_TYPE_COLORS = {
    View: '#3b82f6',
    Text: '#eab308',
    Image: '#a855f7',
    Table: '#22c55e',
    TableRow: '#10b981',
    TableCell: '#34d399',
    FixedHeader: '#ef4444',
    FixedFooter: '#ef4444',
    Rect: '#6b7280',
    None: '#6b7280',
  };

  function drawOverlays(hoverElement, hoverPageIdx) {
    const wrappers = pagesEl.querySelectorAll('.page-wrapper');
    wrappers.forEach((wrapper) => {
      const overlay = wrapper.querySelector('.overlay-canvas');
      const pageIdx = parseInt(wrapper.dataset.pageIndex, 10);
      const dpr = window.devicePixelRatio || 1;
      const ctx = overlay.getContext('2d');
      ctx.clearRect(0, 0, overlay.width, overlay.height);
      ctx.save();
      ctx.scale(dpr, dpr);

      if (!layoutData || !layoutData.pages[pageIdx]) { ctx.restore(); return; }
      const page = layoutData.pages[pageIdx];

      // Layout mode: colored outlines by nodeType
      if (currentMode === 'layout') {
        drawLayoutOverlay(ctx, page.elements);
      }

      // Margins mode
      if (currentMode === 'margins') {
        drawMarginsOverlay(ctx, page);
      }

      // Breaks mode
      if (currentMode === 'breaks') {
        drawBreaksOverlay(ctx, page, pageIdx);
      }

      // Hover highlight (layout mode)
      if (hoverElement && hoverPageIdx === pageIdx) {
        const color = NODE_TYPE_COLORS[hoverElement.nodeType] || '#a1a1aa';
        ctx.fillStyle = color.replace(')', ', 0.08)').replace('rgb', 'rgba').replace('#', '');
        // Use hex with alpha
        ctx.fillStyle = hexToRgba(color, 0.1);
        ctx.fillRect(
          hoverElement.x * currentZoom,
          hoverElement.y * currentZoom,
          hoverElement.width * currentZoom,
          hoverElement.height * currentZoom
        );
        ctx.strokeStyle = hexToRgba(color, 0.6);
        ctx.lineWidth = 1;
        ctx.strokeRect(
          hoverElement.x * currentZoom,
          hoverElement.y * currentZoom,
          hoverElement.width * currentZoom,
          hoverElement.height * currentZoom
        );
      }

      // Selected element highlight
      if (selectedElement && selectedPageIdx === pageIdx) {
        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 2;
        ctx.setLineDash([]);
        ctx.strokeRect(
          selectedElement.x * currentZoom,
          selectedElement.y * currentZoom,
          selectedElement.width * currentZoom,
          selectedElement.height * currentZoom
        );

        // Margin visualization
        if (inspectorOpen && selectedElement.style) {
          const s = selectedElement.style;
          const m = s.margin;
          const ex = selectedElement.x * currentZoom;
          const ey = selectedElement.y * currentZoom;
          const ew = selectedElement.width * currentZoom;
          const eh = selectedElement.height * currentZoom;

          ctx.fillStyle = 'rgba(251, 146, 60, 0.1)';
          // Top margin
          if (m.top > 0) ctx.fillRect(ex, ey - m.top * currentZoom, ew, m.top * currentZoom);
          // Bottom margin
          if (m.bottom > 0) ctx.fillRect(ex, ey + eh, ew, m.bottom * currentZoom);
          // Left margin
          if (m.left > 0) ctx.fillRect(ex - m.left * currentZoom, ey, m.left * currentZoom, eh);
          // Right margin
          if (m.right > 0) ctx.fillRect(ex + ew, ey, m.right * currentZoom, eh);

          // Padding visualization
          const p = s.padding;
          const bw = s.borderWidth;
          ctx.fillStyle = 'rgba(74, 222, 128, 0.1)';
          const innerX = ex + bw.left * currentZoom;
          const innerY = ey + bw.top * currentZoom;
          const innerW = ew - (bw.left + bw.right) * currentZoom;
          const innerH = eh - (bw.top + bw.bottom) * currentZoom;
          // Top padding
          if (p.top > 0) ctx.fillRect(innerX, innerY, innerW, p.top * currentZoom);
          // Bottom padding
          if (p.bottom > 0) ctx.fillRect(innerX, innerY + innerH - p.bottom * currentZoom, innerW, p.bottom * currentZoom);
          // Left padding
          if (p.left > 0) ctx.fillRect(innerX, innerY + p.top * currentZoom, p.left * currentZoom, innerH - (p.top + p.bottom) * currentZoom);
          // Right padding
          if (p.right > 0) ctx.fillRect(innerX + innerW - p.right * currentZoom, innerY + p.top * currentZoom, p.right * currentZoom, innerH - (p.top + p.bottom) * currentZoom);
        }
      }

      ctx.restore();
    });
  }

  function drawLayoutOverlay(ctx, elements) {
    for (const el of elements) {
      const color = NODE_TYPE_COLORS[el.nodeType] || '#6b7280';
      ctx.strokeStyle = hexToRgba(color, 0.5);
      ctx.lineWidth = 1;
      ctx.strokeRect(
        el.x * currentZoom,
        el.y * currentZoom,
        el.width * currentZoom,
        el.height * currentZoom
      );
      // Recurse into children
      if (el.children && el.children.length) {
        drawLayoutOverlay(ctx, el.children);
      }
    }
  }

  function drawMarginsOverlay(ctx, page) {
    // Page margin boundaries
    ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)';
    ctx.lineWidth = 1;
    ctx.setLineDash([6, 4]);
    ctx.strokeRect(
      page.contentX * currentZoom,
      page.contentY * currentZoom,
      page.contentWidth * currentZoom,
      page.contentHeight * currentZoom
    );
    ctx.setLineDash([]);

    // Margin strips (tinted areas outside content)
    ctx.fillStyle = 'rgba(59, 130, 246, 0.05)';
    const pw = page.width * currentZoom;
    const ph = page.height * currentZoom;
    const cx = page.contentX * currentZoom;
    const cy = page.contentY * currentZoom;
    const cw = page.contentWidth * currentZoom;
    const ch = page.contentHeight * currentZoom;
    // Top
    ctx.fillRect(0, 0, pw, cy);
    // Bottom
    ctx.fillRect(0, cy + ch, pw, ph - cy - ch);
    // Left
    ctx.fillRect(0, cy, cx, ch);
    // Right
    ctx.fillRect(cx + cw, cy, pw - cx - cw, ch);

    // Element margin/padding visualization
    drawElementSpacing(ctx, page.elements);
  }

  function drawElementSpacing(ctx, elements) {
    for (const el of elements) {
      if (el.style) {
        const m = el.style.margin;
        const p = el.style.padding;

        // Margin areas (orange tint)
        if (m.top > 0 || m.bottom > 0 || m.left > 0 || m.right > 0) {
          ctx.fillStyle = 'rgba(251, 146, 60, 0.08)';
          const ex = el.x * currentZoom;
          const ey = el.y * currentZoom;
          const ew = el.width * currentZoom;
          const eh = el.height * currentZoom;
          if (m.top > 0) ctx.fillRect(ex, ey - m.top * currentZoom, ew, m.top * currentZoom);
          if (m.bottom > 0) ctx.fillRect(ex, ey + eh, ew, m.bottom * currentZoom);
          if (m.left > 0) ctx.fillRect(ex - m.left * currentZoom, ey, m.left * currentZoom, eh);
          if (m.right > 0) ctx.fillRect(ex + ew, ey, m.right * currentZoom, eh);
        }

        // Padding areas (green tint)
        if (p.top > 0 || p.bottom > 0 || p.left > 0 || p.right > 0) {
          ctx.fillStyle = 'rgba(74, 222, 128, 0.08)';
          const bw = el.style.borderWidth;
          const ix = (el.x + bw.left) * currentZoom;
          const iy = (el.y + bw.top) * currentZoom;
          const iw = (el.width - bw.left - bw.right) * currentZoom;
          const ih = (el.height - bw.top - bw.bottom) * currentZoom;
          if (p.top > 0) ctx.fillRect(ix, iy, iw, p.top * currentZoom);
          if (p.bottom > 0) ctx.fillRect(ix, iy + ih - p.bottom * currentZoom, iw, p.bottom * currentZoom);
          if (p.left > 0) ctx.fillRect(ix, iy + p.top * currentZoom, p.left * currentZoom, ih - (p.top + p.bottom) * currentZoom);
          if (p.right > 0) ctx.fillRect(ix + iw - p.right * currentZoom, iy + p.top * currentZoom, p.right * currentZoom, ih - (p.top + p.bottom) * currentZoom);
        }
      }
      if (el.children && el.children.length) {
        drawElementSpacing(ctx, el.children);
      }
    }
  }

  function drawBreaksOverlay(ctx, page, pageIdx) {
    if (pageIdx > 0) {
      const y = page.contentY * currentZoom;
      ctx.strokeStyle = '#ef4444';
      ctx.lineWidth = 1.5;
      ctx.setLineDash([8, 4]);
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(page.width * currentZoom, y);
      ctx.stroke();
      ctx.setLineDash([]);

      // Y-coordinate label
      ctx.fillStyle = '#ef4444';
      ctx.font = '10px ' + getComputedStyle(document.body).fontFamily;
      ctx.fillText(`break at y=${fmt(page.contentY)}`, 8 * currentZoom, y - 4);
    }

    // Show page number label
    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.font = `bold ${12 * currentZoom}px ${getComputedStyle(document.body).fontFamily}`;
    ctx.fillText(
      `Page ${pageIdx + 1}`,
      page.contentX * currentZoom + 4,
      (page.contentY + 14) * currentZoom
    );
  }

  function hexToRgba(hex, alpha) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
  }

  // ── Full reload cycle ─────────────────────────────────────────
  async function reload() {
    errorEl.style.display = 'none';
    await renderPdfPages();
    await fetchLayout();
    drawOverlays();
  }

  // ── Keyboard shortcuts ────────────────────────────────────────
  document.addEventListener('keydown', (e) => {
    // Mode shortcuts: 1-4
    if (!e.metaKey && !e.ctrlKey && !e.altKey) {
      if (e.key === '1') { e.preventDefault(); setMode('preview'); }
      if (e.key === '2') { e.preventDefault(); setMode('layout'); }
      if (e.key === '3') { e.preventDefault(); setMode('margins'); }
      if (e.key === '4') { e.preventDefault(); setMode('breaks'); }
      if (e.key === 'Escape') { e.preventDefault(); closeInspector(); }
    }

    // Zoom shortcuts: Cmd/Ctrl + / - / 0
    if (e.metaKey || e.ctrlKey) {
      if (e.key === '=' || e.key === '+') { e.preventDefault(); zoomIn(); }
      if (e.key === '-') { e.preventDefault(); zoomOut(); }
      if (e.key === '0') { e.preventDefault(); zoomToFit(); }
    }
  });

  // Cmd/Ctrl + scroll to zoom
  containerEl.addEventListener('wheel', (e) => {
    if (e.metaKey || e.ctrlKey) {
      e.preventDefault();
      if (e.deltaY < 0) zoomIn();
      else zoomOut();
    }
  }, { passive: false });

  // ── WebSocket ─────────────────────────────────────────────────
  function connectWs() {
    const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
    const ws = new WebSocket(`${protocol}//${location.host}`);

    ws.addEventListener('open', () => {
      statusDot.className = 'status-dot connected';
    });

    ws.addEventListener('close', () => {
      statusDot.className = 'status-dot disconnected';
      setTimeout(connectWs, 1000);
    });

    ws.addEventListener('message', async (event) => {
      const msg = JSON.parse(event.data);

      if (msg.type === 'reload') {
        if (msg.renderTime) {
          renderTimeEl.textContent = msg.renderTime + 'ms';
          renderBadge.style.display = 'inline-flex';
        }
        await reload();
      }

      if (msg.type === 'error') {
        errorEl.querySelector('.error-dismiss').nextSibling?.remove();
        errorEl.appendChild(document.createTextNode(msg.message));
        errorEl.style.display = 'block';
      }
    });
  }

  // ── Init ──────────────────────────────────────────────────────
  connectWs();
  reload().then(() => {
    // Zoom to fit after initial render
    setTimeout(zoomToFit, 100);
  }).catch(() => {});
</script>
</body>
</html>
